{"meta":{"title":"Science & Technology For Future","subtitle":"Sciencec and Technology","description":null,"author":"Arron Rose","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"if-else_if+","date":"2017-04-14T02:08:51.742Z","updated":"2017-04-14T02:08:51.817Z","comments":true,"path":"2017/04/14/if-else_if+/","link":"","permalink":"http://yoursite.com/2017/04/14/if-else_if+/","excerpt":"","text":"最近在OJ上刷题，总是会“莫名其妙”的出现许多错误，截止今天再次莫名出错，着实不能再忍受，仔细翻阅与之前犯错的对比发现，对于if-else/if理解的竟然有偏差，直接上代码 for i in range(10): if i&lt;5: print &quot;A&quot;, print &quot;B&quot;, A B A B A B A B A B B B B B Bfor i in range(10): if i&lt;5: print &quot;A&quot;, else: print &quot;B&quot;, A A A A A B B B B B重新翻阅基础知识，if/else 单词执行只执行其中一步，同try/except； 而if+，之后的语句则是不管if执行与否，其后程序必执行 很遗憾，这么简单的问题啊，竟然稀里糊涂的用了这么久（基础啊基础！）","categories":[],"tags":[],"keywords":[]},{"title":"echarts collocation china_map (geo)","slug":"echarts_chinamap","date":"2017-04-12T07:54:38.989Z","updated":"2017-04-12T08:02:32.250Z","comments":true,"path":"2017/04/12/echarts_chinamap/","link":"","permalink":"http://yoursite.com/2017/04/12/echarts_chinamap/","excerpt":"","text":"1.图表基本配置// 初始化echarts示例mapChart var mapChart = echarts.init(document.getElementById(&apos;mapcontainer&apos;)); // mapChart的配置 var option = { }; 2.新建一个地理坐标系 geo ，地图类型为中国地图var option = { geo: { map: &apos;china&apos; } geo.map 属性定义该地理坐标系中的地图数据，这里我们要用 china.js ，设置map值为 ‘china’ 。这里需要注意，中国地图的map值为 ‘china’ ，世界地图的map值为 ‘world’ ，但如果要引用省市自治区地图ap 值为简体中文，例如 beijing.js ，map 值为 ’北京’ 。 3.调用 setOption(option) 为图表设置配置项mapChart.setOption(option); 4.基本的地图设置var option = { geo: { map: &apos;china&apos;, itemStyle: { // 定义样式 normal: { // 普通状态下的样式 areaColor: &apos;#323c48&apos;, borderColor: &apos;#111&apos; }, emphasis: { // 高亮状态下的样式 areaColor: &apos;#2a333d&apos; } } }, backgroundColor: &apos;#404a59&apos;, // 图表背景色 } 5.绘制散点图(加载数据) 新建散点图 series 在 option 中添加一个 series ， series 的类型为散点图 scatter ，坐标系为地理坐标系 geo var option = { geo: { ... }, backgroundColor: &apos;#404a59&apos;, series: [ { name: &apos;销量&apos;, // series名称 type: &apos;scatter&apos;, // series图表类型 coordinateSystem: &apos;geo&apos; // series坐标系类型 } ] } 添加数据 ECharts 中 series.data 是定义图表数据内容的数组，其中每个项数据格式为（标准格式） { name: &apos;北京&apos;, // 数据项名称，在这里指地区名称 value: [ // 数据项值 116.46, // 地理坐标，经度 39.92, // 地理坐标，纬度 340 // 北京的数值，可添加 ] } 添加数据（自处理依据需求） 首先我们将需要渲染的数据转换成上述数据格式，存在一个变量中 var myData = [ {name: &apos;北京&apos;, value: [121.15, 31.89, value1，value2]}, {name: &apos;天津&apos;, value: [109.781327, 39.608266, value1，value2]}, {name: &apos;广州&apos;, value: [120.38, 37.35, value1，value2]}, {name: &apos;西安&apos;, value: [122.207216, 29.985295, value1，value2]}, ... ] 然后，将 myData 赋值给 series.data var option = { geo: { ... }, backgroundColor: &apos;#404a59&apos;, series: [ { name: &apos;销量&apos;, type: &apos;scatter&apos;, coordinateSystem: &apos;geo&apos;, data: myData // series数据内容 } ] } 添加视觉映射组件 视觉映射组件 是标识某一数据范围内数据及颜色对应关系的控件，视觉映射组件分为连续型和分段型，这里我们选用连续型 type:continuous 。同时，通过视觉映射组件可以实现 ECharts 值域漫游功能，即通过拖拽控件手柄选择不同数值范围，达到对图表数据的筛选显示。 在 visualMap 属性中设置值域控件的相关配置 var option = { ... visualMap: { type: &apos;continuous&apos;, // 连续型 min: 0, // 值域最小值，必须参数 max: 200, // 值域最大值，必须参数 calculable: true, // 是否启用值域漫游 inRange: { color: [&apos;#50a3ba&apos;,&apos;#eac736&apos;,&apos;#d94e5d&apos;] // 指定数值从低到高时的颜色变化 }, textStyle: { color: &apos;#fff&apos; // 值域控件的文本颜色 } } } 6.结果图http://echarts.baidu.com/demo.html#scatter-map","categories":[],"tags":[],"keywords":[]},{"title":"Deadlock","slug":"deadlock","date":"2017-04-12T07:09:03.924Z","updated":"2017-04-12T07:03:52.096Z","comments":true,"path":"2017/04/12/deadlock/","link":"","permalink":"http://yoursite.com/2017/04/12/deadlock/","excerpt":"","text":"1.死锁的定义如果一个进程集合中的每个进程都在等待只能由该进程集合中其他进程才能引发的事件，那么该进程集合就是死锁的。 2.死锁产生的原因 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当等。 3.死锁产生的必要条件 互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待条件：已经得到了某个资源的进程可以再请求新的资源。 不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，只能被占有它的进程显式地释放； 环路等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 4.处理死锁的四种策略 鸵鸟策略（忽略死锁） 检测死锁并恢复 仔细对资源进行分配，动态地避免死锁 通过破坏引起死锁的四个必要条件之一，防止死锁的产生 5.避免死锁的主要算法银行家算法 避免死锁的主要算法是基于一个安全状态的概念。在任何时刻，如果没有死锁发生，并且即使所有进程忽然请求对资源的最大请求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。银行家算法从判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求，如果满足请求后系统仍然是安全的，就予以分配。不安全状态不一定引起死锁，因为客户不一定需要其最大贷款额度。*","categories":[],"tags":[],"keywords":[]},{"title":"single instance","slug":"single_instance","date":"2017-04-12T06:41:13.665Z","updated":"2017-04-12T07:08:57.415Z","comments":true,"path":"2017/04/12/single_instance/","link":"","permalink":"http://yoursite.com/2017/04/12/single_instance/","excerpt":"单例模式（四种方法）方法1 实现new方法 并在将一个类的实例绑定到类变量_instance上, 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a one和two完全相同,可以用id(), ==, is检测 print id(one) 29097904 print id(two) 29097904 print one == two True print one is two True","text":"单例模式（四种方法）方法1 实现new方法 并在将一个类的实例绑定到类变量_instance上, 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a one和two完全相同,可以用id(), ==, is检测 print id(one) 29097904 print id(two) 29097904 print one == two True print one is two True 方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法) 同一个类的所有实例天然拥有相同的行为(方法), 只需要保证同一个类的所有实例具有相同的状态(属性)即可 所有实例共享属性的最简单最直接的方法就是dict属性指向(引用)同一个字典(dict) class Borg(object): _state = {} def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return ob class MyClass2(Borg): a = 1 one = MyClass2() two = MyClass2() two.a = 3 print one.a 3 print id(one) 28873680 print id(two) 28873712 print one == two False print one is two False 但是one和two具有相同的（同一个dict属性）,见: print id(one.__dict__) 30104000 print id(two.__dict__) 30104000 方法3:本质上是方法1的升级（或者说高级）版 使用metaclass（元类）的高级python用法 class Singleton2(type): def __init__(cls, name, bases, dict): super(Singleton2, cls).__init__(name, bases, dict) cls._instance = None def __call__(cls, *args, **kw): if cls._instance is None: cls._instance = super(Singleton2, cls).__call__(*args, **kw) return cls._instance class MyClass3(object): __metaclass__ = Singleton2 one = MyClass3() two = MyClass3() two.a = 3 print one.a 3 print id(one) 31495472 id(two) 31495472 print one == two True print one is two True 方法4:也是方法1的升级（高级）版本 使用装饰器(decorator), 这是一种更pythonic,更elegant的方法, 单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的 def singleton(cls, *args, **kw): instances = {} def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return _singleton @singleton class MyClass4(object): a = 1 def __init__(self, x=0): self.x = x one = MyClass4() two = MyClass4() two.a = 3 print one.a 3 print id(one) 29660784 print id(two) 29660784 print one == two True print one is two True one.x = 1 print one.x 1 print two.x 1","categories":[],"tags":[],"keywords":[]},{"title":"mime.type","slug":"mime_type","date":"2017-04-10T06:04:14.888Z","updated":"2017-04-10T06:04:14.996Z","comments":true,"path":"2017/04/10/mime_type/","link":"","permalink":"http://yoursite.com/2017/04/10/mime_type/","excerpt":"","text":"常见的MIME类型 超文本标记语言文本 .htm,.html text/html 普通文本.txt text/plain RTF文本 .rtf application/rtf GIF图形 .gif image/gif JPEG图形 .ipeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 .mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar","categories":[],"tags":[],"keywords":[]},{"title":"HEXO collocation","slug":"hexo_collocation","date":"2017-04-06T02:30:00.824Z","updated":"2017-04-12T06:45:25.978Z","comments":true,"path":"2017/04/06/hexo_collocation/","link":"","permalink":"http://yoursite.com/2017/04/06/hexo_collocation/","excerpt":"部署步骤一、配置环境1.安装node.js2.安装git3.申请github4.安装hexo$ sudo npm install –g hexo 5.初始化$ hexo init 6.生成静态页面$ hexo generate 7.本地启动$ hexo server –p 3000 （端口号本地自定）","text":"部署步骤一、配置环境1.安装node.js2.安装git3.申请github4.安装hexo$ sudo npm install –g hexo 5.初始化$ hexo init 6.生成静态页面$ hexo generate 7.本地启动$ hexo server –p 3000 （端口号本地自定） 二、配置gihub1.建立仓库（repository） 创建仓库名 your_name.github.io 关联github $ vim _config.yml deploy: type:git (github) repository: http://github.com/arronrose/Arronrose.github.io.git branch: master 部署git在线上 npm install hexo-deployer-git –save 配置hexo hexo deploy 2.部署步骤 hexo clean hexo generate hexo deploy 添加文章$ hexo new “my new post” 得到G:\\blog\\source_posts\\my-new-post.md 修改my-new-post.md（markdown 文件，同HTML，比html精简） $ hexo g 等价于 generate $ hexo d 等价于 deploy","categories":[],"tags":[],"keywords":[]},{"title":"callback_function","slug":"callback_function","date":"2017-04-06T02:19:56.403Z","updated":"2017-04-10T02:42:23.226Z","comments":true,"path":"2017/04/06/callback_function/","link":"","permalink":"http://yoursite.com/2017/04/06/callback_function/","excerpt":"什么是回调函数？我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。","text":"什么是回调函数？我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。如下图所示（图片来源：维基百科）： 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例： even.py 回调函数1生成一个2k形式的偶数 def double(x): return x * 2 回调函数2生成一个4k形式的偶数 def quadruple(x): return x * 4 callback_demo.py from even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数 def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数(主函数)def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if __name__ == &quot;__main__&quot;: main() 运行callback_demp.py，输出如下： 3 5 9 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"crontab","slug":"crontab_time","date":"2017-04-05T13:35:42.719Z","updated":"2017-04-05T13:35:42.809Z","comments":true,"path":"2017/04/05/crontab_time/","link":"","permalink":"http://yoursite.com/2017/04/05/crontab_time/","excerpt":"一. crontab定时器服务配置1、定义： crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。","text":"一. crontab定时器服务配置1、定义： crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。 2、安装（默认自带crontab） 假如执行crontab报下面的错误即需要安装一下。 bash: crontab: command not found 确认crontab是否安装： 执行 crontab 命令如果报 command not found，就表明没有安装 安装 crontab 执行 yum install -y vixie-cron 确认是否安装成功: 执行 crontab -l 看是否设置了开机自动启动 chkconfig –list crond 启动crontab service crond start 二. 为当前用户创建定时服务 键入 crontab -e 编辑crontab服务文件 例如 文件内容如下： /2 * /bin/sh /home/admin/jiaoben/buy/deleteFile.sh 保存文件并并退出 /2 * /bin/sh /home/admin/jiaoben/buy/deleteFile.sh /2 * 通过这段字段可以设定什么时候执行脚本 /bin/sh /home/admin/jiaoben/buy/deleteFile.sh 这一字段可以设定你要执行的脚本，这里要注意一下bin/sh 是指运行 脚本的命令 后面一段时指脚本存放的路径 查看该用户下的crontab服务是否创建成功， 用 crontab -l 命令 启动crontab服务 一般启动服务用 /sbin/service crond start 若是根用户的cron服务可以用 sudo service crond start， 这里还是要注意 下 不同版本Linux系统启动的服务的命令也不同 ，像我的虚拟机里只需用 sudo service cron restart 即可，若是在根用下直接键入service cron start就能启动服务 查看服务是否已经运行用 ps -ax | grep cron crontab命令 crontab -u //设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数 crontab -l //列出某个用户cron服务的详细内容 rontab -r //删除没个用户的cron服务 crontab -e //编辑某个用户的cron服务 crontab命令选项: -u指定一个用户 -l列出某个用户的任务计划 -r删除某个用户的任务 -e编辑某个用户的任务 cron文件语法: 分 小时 日 月 星期 命令 0-59 0-23 1-31 1-12 0-6 command (取值范围,0表示周日一般一行对应一个任务) 记住几个特殊符号的含义: “*”代表取值范围内的数字, “/”代表”每”, “-”代表从某个数字到某个数字, “,”分开几个离散的数字 新增调度任务 新增调度任务可用两种方法： 1)、在命令行输入: crontab -e 然后添加相应的任务，wq存盘退出。 2)、直接编辑/etc/crontab 文件，即vi /etc/crontab，添加相应的任务。 查看调度任务 crontab -l //列出当前的所有调度任务 crontab -l -u jp //列出用户jp的所有调度任务 删除任务调度工作 crontab -r //删除所有任务调度工作","categories":[],"tags":[],"keywords":[]},{"title":"mysql deploy","slug":"mysql_deploy","date":"2017-04-05T12:25:15.353Z","updated":"2017-04-05T12:49:23.114Z","comments":true,"path":"2017/04/05/mysql_deploy/","link":"","permalink":"http://yoursite.com/2017/04/05/mysql_deploy/","excerpt":"","text":"MySQL数据库如何实现远程登录1.修改配置文件/etc/mysql找到my.cnf，不清楚mysql配置文件编码的话，建议使用vi /etc/mysql/my.cnfi到bind-address 127.0.0.1注释掉这句话：# bind-address 127.0.0.1：wq保存并退出，如果出现问题，则使用：w !sudo tee % 2.修改mysql hostmysql&gt; use mysqlmysql&gt; update user set Host=’%’ where User=’root’mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘myuser’@’%’ IDENTIFIED BY ‘mypwd’ WITH GRANT OPTIONmysql&gt; FLUSH PRIVILEGES 3.重启mysql/etc/init.d/mysql stop/etc/init.d/mysql start","categories":[],"tags":[],"keywords":[]},{"title":"git conclusion","slug":"git_conclusion","date":"2017-04-05T08:49:59.000Z","updated":"2017-04-05T08:54:20.337Z","comments":true,"path":"2017/04/05/git_conclusion/","link":"","permalink":"http://yoursite.com/2017/04/05/git_conclusion/","excerpt":"","text":"git是三个文件（本地–本地隐藏文件.git–远程仓库）先pull再add然后commit最后push 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com” cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com” (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag (打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中)","categories":[],"tags":[],"keywords":[]},{"title":"asynchronous","slug":"asynchronous","date":"2016-11-10T03:16:55.000Z","updated":"2017-04-05T08:32:05.357Z","comments":true,"path":"2016/11/10/asynchronous/","link":"","permalink":"http://yoursite.com/2016/11/10/asynchronous/","excerpt":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);","text":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);什么是回调函数？ 我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。 打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势 从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例： even.py回调函数1生成一个2k形式的偶数def double(x): return x * 2 回调函数2生成一个4k形式的偶数def quadruple(x): return x * 4 callback_demo.pyfrom even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数，这里是程序的主函数def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if name == “main“: main() 运行callback_demp.py，输出如下：359 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"To 365","slug":"To 365","date":"2016-11-06T14:57:12.000Z","updated":"2016-11-06T15:16:31.427Z","comments":true,"path":"2016/11/06/To 365/","link":"","permalink":"http://yoursite.com/2016/11/06/To 365/","excerpt":"","text":"都深夜了，这23岁的生日过的也不是那么的顺畅，我也能感受到这叹息的威力，划破黑衣的霾，直击人心得脉。想成事，必先受其苦，这是亘古不变的，经历了这么多事，风霜阴雨的，哪能忘却了？只是，日复一日的生活，水滴石穿着我们的爱心， 耐心和信心。唯有不忘初心，方能见前后，知因果。我写着写着自己都不知道要说啥，不妨罗列出来，锱铢一二： 干什么事都得定好目标，有了目标人才会有动力，即时面临艰难险阻，咬牙抬头的那一刻，看到梦想的目标，定然也会蓄力拼搏，殊死搏斗，不向命运低头； 出了较长远的大目标外（梦想如是。。。），也要定阶段性的小目标，一方面，小的目标可以较为容易的实现，可以激励自己，让自己获得长久“战斗”下去的勇气，另一方面，也告诫自己，困难还很多，千万别“轻敌”； 情感要有，纪律也不能丢掉。无规矩，不方圆，这种到底无需赘述。是非分明，奖惩分明，要的不是铁面无私，要的是活的明白！浑浑噩噩的，一天天过去了，一件件事经历了，然而并不能为以后树立良好的经验榜样，只有明明白白的活着，才能感受到生命的意义。除此以外，规矩的建立也是为了防止自己逾越雷池，犯下大错，因此，是亟待建立并付诸于心动的； 互相提高才是正道，共同进步才是正确。且说不到近朱者赤近墨者黑（没有那么严重），就用榜样来讲吧，良好的榜样，才能促进共同的进步，如果不思进取，最终的结果也定然不会太美丽。爱情终究会成为亲情，成为弥漫在你周围的空气一般，平淡，在平淡。长远的认识，或许会帮助自己更加轻松的理解生活的真谛。加油！","categories":[],"tags":[],"keywords":[]},{"title":"Nginx","slug":"Nginx","date":"2016-11-05T06:39:17.000Z","updated":"2016-11-05T06:57:41.397Z","comments":true,"path":"2016/11/05/Nginx/","link":"","permalink":"http://yoursite.com/2016/11/05/Nginx/","excerpt":"","text":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-11-05T06:07:27.123Z","updated":"2016-11-05T06:30:07.689Z","comments":true,"path":"2016/11/05/hello-world/","link":"","permalink":"http://yoursite.com/2016/11/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}