{"meta":{"title":"Science & Technology For Future","subtitle":"Sciencec and Technology","description":null,"author":"Arron Rose","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"asynchronous","slug":"asynchronous","date":"2016-11-10T03:16:55.000Z","updated":"2017-04-05T08:30:23.830Z","comments":true,"path":"2016/11/10/asynchronous/","link":"","permalink":"http://yoursite.com/2016/11/10/asynchronous/","excerpt":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”); 什么是回调函数？ 我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。 打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势 从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：","text":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”); 什么是回调函数？ 我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。 打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势 从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：even.py回调函数1生成一个2k形式的偶数def double(x): return x * 2 回调函数2生成一个4k形式的偶数def quadruple(x): return x * 4 callback_demo.pyfrom even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数，这里是程序的主函数def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if name == “main“: main() 运行callback_demp.py，输出如下：359 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"To 365","slug":"To 365","date":"2016-11-06T14:57:12.000Z","updated":"2016-11-06T15:16:31.427Z","comments":true,"path":"2016/11/06/To 365/","link":"","permalink":"http://yoursite.com/2016/11/06/To 365/","excerpt":"","text":"都深夜了，这23岁的生日过的也不是那么的顺畅，我也能感受到这叹息的威力，划破黑衣的霾，直击人心得脉。想成事，必先受其苦，这是亘古不变的，经历了这么多事，风霜阴雨的，哪能忘却了？只是，日复一日的生活，水滴石穿着我们的爱心， 耐心和信心。唯有不忘初心，方能见前后，知因果。我写着写着自己都不知道要说啥，不妨罗列出来，锱铢一二： 干什么事都得定好目标，有了目标人才会有动力，即时面临艰难险阻，咬牙抬头的那一刻，看到梦想的目标，定然也会蓄力拼搏，殊死搏斗，不向命运低头； 出了较长远的大目标外（梦想如是。。。），也要定阶段性的小目标，一方面，小的目标可以较为容易的实现，可以激励自己，让自己获得长久“战斗”下去的勇气，另一方面，也告诫自己，困难还很多，千万别“轻敌”； 情感要有，纪律也不能丢掉。无规矩，不方圆，这种到底无需赘述。是非分明，奖惩分明，要的不是铁面无私，要的是活的明白！浑浑噩噩的，一天天过去了，一件件事经历了，然而并不能为以后树立良好的经验榜样，只有明明白白的活着，才能感受到生命的意义。除此以外，规矩的建立也是为了防止自己逾越雷池，犯下大错，因此，是亟待建立并付诸于心动的； 互相提高才是正道，共同进步才是正确。且说不到近朱者赤近墨者黑（没有那么严重），就用榜样来讲吧，良好的榜样，才能促进共同的进步，如果不思进取，最终的结果也定然不会太美丽。爱情终究会成为亲情，成为弥漫在你周围的空气一般，平淡，在平淡。长远的认识，或许会帮助自己更加轻松的理解生活的真谛。加油！","categories":[],"tags":[],"keywords":[]},{"title":"Nginx","slug":"Nginx","date":"2016-11-05T06:39:17.000Z","updated":"2016-11-05T06:57:41.397Z","comments":true,"path":"2016/11/05/Nginx/","link":"","permalink":"http://yoursite.com/2016/11/05/Nginx/","excerpt":"","text":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-11-05T06:07:27.123Z","updated":"2016-11-05T06:30:07.689Z","comments":true,"path":"2016/11/05/hello-world/","link":"","permalink":"http://yoursite.com/2016/11/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}