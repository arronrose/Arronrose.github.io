{"meta":{"title":"Science & Technology For Future","subtitle":"Sciencec and Technology","description":null,"author":"Arron Rose","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"awesome python API & plugs","slug":"awesome_python","date":"2017-05-08T07:46:17.061Z","updated":"2017-05-08T07:53:26.097Z","comments":true,"path":"2017/05/08/awesome_python/","link":"","permalink":"http://yoursite.com/2017/05/08/awesome_python/","excerpt":"Awesome Python A curated list of awesome Python frameworks, libraries, software and resources. Inspired by awesome-php. Awesome Python Admin Panels Algorithms and Design Patterns Anti-spam Asset Management Audio Authentication Build Tools Caching ChatOps Tools CMS Code Analysis and Linter Command-line Tools Compatibility Computer Vision Concurrency and Parallelism Configuration Cryptography Data Analysis Data Validation Data Visualization Database Drivers Database Date and Time Debugging Tools Deep Learning DevOps Tools Distribution Documentation Downloader E-commerce Editor Plugins and IDEs Email Environment Management Files Foreign Function Interface Forms Functional Programming Game Development Geolocation GUI Hardware HTML Manipulation HTTP Imagery Implementations Interactive Interpreter Internationalization Job Scheduler Logging Machine Learning MapReduce Miscellaneous Natural Language Processing Network Virtualization Networking News Feed ORM Package Management Package Repositories Permissions Processes Queue RESTful API RPC Servers Science Search Serialization Serverless Frameworks Specific Formats Processing Static Site Generator Tagging Template Engine Testing Text Processing Third-party APIs URL Manipulation Video Web Content Extracting Web Crawling Web Frameworks WebSocket WSGI Servers Services Code Quality Continuous Integration Resources Podcasts Twitter Websites Weekly Other Awesome Lists Contributing","text":"Awesome Python A curated list of awesome Python frameworks, libraries, software and resources. Inspired by awesome-php. Awesome Python Admin Panels Algorithms and Design Patterns Anti-spam Asset Management Audio Authentication Build Tools Caching ChatOps Tools CMS Code Analysis and Linter Command-line Tools Compatibility Computer Vision Concurrency and Parallelism Configuration Cryptography Data Analysis Data Validation Data Visualization Database Drivers Database Date and Time Debugging Tools Deep Learning DevOps Tools Distribution Documentation Downloader E-commerce Editor Plugins and IDEs Email Environment Management Files Foreign Function Interface Forms Functional Programming Game Development Geolocation GUI Hardware HTML Manipulation HTTP Imagery Implementations Interactive Interpreter Internationalization Job Scheduler Logging Machine Learning MapReduce Miscellaneous Natural Language Processing Network Virtualization Networking News Feed ORM Package Management Package Repositories Permissions Processes Queue RESTful API RPC Servers Science Search Serialization Serverless Frameworks Specific Formats Processing Static Site Generator Tagging Template Engine Testing Text Processing Third-party APIs URL Manipulation Video Web Content Extracting Web Crawling Web Frameworks WebSocket WSGI Servers Services Code Quality Continuous Integration Resources Podcasts Twitter Websites Weekly Other Awesome Lists Contributing Admin PanelsLibraries for administrative interfaces. Ajenti - The admin panel your servers deserve. django-suit - Alternative Django Admin-Interface (free only for Non-commercial use). django-xadmin - Drop-in replacement of Django admin comes with lots of goodies. flask-admin - Simple and extensible administrative interface framework for Flask. flower - Real-time monitor and web admin for Celery. Grappelli - A jazzy skin for the Django Admin-Interface. Wooey - A Django app which creates automatic web UIs for Python scripts. Algorithms and Design PatternsPython implementation of algorithms and design patterns. algorithms - A module of algorithms for Python. PyPattyrn - A simple yet effective library for implementing common design patterns. python-patterns - A collection of design patterns in Python. sortedcontainers - Fast, pure-Python implementation of SortedList, SortedDict, and SortedSet types. Anti-spamLibraries for fighting spam. django-simple-captcha - A simple and highly customizable Django app to add captcha images to any Django form. django-simple-spam-blocker - Simple spam blocker for Django. Asset ManagementTools for managing, compressing and minifying website assets. django-compressor - Compresses linked and inline JavaScript or CSS into a single cached file. django-pipeline - An asset packaging library for Django. django-storages - A collection of custom storage back ends for Django. fanstatic - Packages, optimizes, and serves static file dependencies as Python packages. fileconveyor - A daemon to detect and sync files to CDNs, S3 and FTP. flask-assets - Helps you integrate webassets into your Flask app. jinja-assets-compressor - A Jinja extension to compile and compress your assets. webassets - Bundles, optimizes, and manages unique cache-busting URLs for static resources. AudioLibraries for manipulating audio. audiolazy - Expressive Digital Signal Processing (DSP) package for Python. audioread - Cross-library (GStreamer + Core Audio + MAD + FFmpeg) audio decoding. beets - A music library manager and MusicBrainz tagger. dejavu - Audio fingerprinting and recognition. django-elastic-transcoder - Django + Amazon Elastic Transcoder. eyeD3 - A tool for working with audio files, specifically MP3 files containing ID3 metadata. id3reader - A Python module for reading MP3 meta data. m3u8 - A module for parsing m3u8 file. mingus - An advanced music theory and notation package with MIDI file and playback support. mutagen - A Python module to handle audio metadata. pyAudioAnalysis - Python Audio Analysis Library: Feature Extraction, Classification, Segmentation and Applications pydub - Manipulate audio with a simple and easy high level interface. pyechonest - Python client for the Echo Nest API. talkbox - A Python library for speech/signal processing. TimeSide - Open web audio processing framework. tinytag - A library for reading music meta data of MP3, OGG, FLAC and Wave files. AuthenticationLibraries for implementing authentications schemes. OAuth Authomatic - Simple but powerful framework agnostic authentication/authorization client. django-allauth - Authentication app for Django that “just works.” django-oauth-toolkit - OAuth 2 goodies for Django. Flask-OAuthlib - OAuth 1.0/a, 2.0 implementation of client and provider for Flask. OAuthLib - A generic and thorough implementation of the OAuth request-signing logic. python-oauth2 - A fully tested, abstract interface to creating OAuth clients and servers. python-social-auth - An easy-to-setup social authentication mechanism. rauth - A Python library for OAuth 1.0/a, 2.0, and Ofly. sanction - A dead simple OAuth2 client implementation. Others jose - JavaScript Object Signing and Encryption draft implementation. PyJWT - Implementation of the JSON Web Token draft 01. python-jws - Implementation of JSON Web Signatures draft 02. python-jwt - Module for generating and verifying JSON Web Tokens. Build ToolsCompile software from source code. BitBake - A make-like build tool for embedded Linux. buildout - A build system for creating, assembling and deploying applications from multiple parts. PlatformIO - A console tool to build code with different development platforms. PyBuilder - A continuous build tool written in pure Python. SCons - A software construction tool. CMSContent Management Systems. django-cms - An Open source enterprise CMS based on the Django. djedi-cms - A lightweight but yet powerful Django CMS with plugins, inline editing and performance in mind. FeinCMS - One of the most advanced Content Management Systems built on Django. Kotti - A high-level, Pythonic web application framework built on Pyramid. Mezzanine - A powerful, consistent, and flexible content management platform. Opps - A Django-based CMS for magazines, newspapers websites and portals with high-traffic. Plone - A CMS built on top of the open source application server Zope. Quokka - Flexible, extensible, small CMS powered by Flask and MongoDB. Wagtail - A Django content management system. Widgy - Last CMS framework, based on Django. CachingLibraries for caching data. Beaker - A library for caching and sessions for use with web applications and stand-alone Python scripts and applications. DiskCache - SQLite and file backed cache backend with faster lookups than memcached and redis. django-cache-machine - Automatic caching and invalidation for Django models. django-cacheops - A slick ORM cache with automatic granular event-driven invalidation. django-viewlet - Render template parts with extended cache control. dogpile.cache - dogpile.cache is next generation replacement for Beaker made by same authors. HermesCache - Python caching library with tag-based invalidation and dogpile effect prevention. johnny-cache - A caching framework for django applications. pylibmc - A Python wrapper around the libmemcached interface. ChatOps ToolsLibraries for chatbot development. Errbot - The easiest and most popular chatbot to implement ChatOps. Code Analysis and LinterLibraries and tools for analysing, parsing and manipulation codebases. Code Analysis coala - Language independent and easily extendable code analysis application. code2flow - Turn your Python and JavaScript code into DOT flowcharts. pycallgraph - A library that visualises the flow (call graph) of your Python application. pysonar2 - A type inferencer and indexer for Python. Linter Flake8 - The modular source code checker: pep8, pyflakes and co. pylama - Code audit tool for Python and JavaScript. Pylint - A Fully customizable source code analyzer. Command-line ToolsLibraries for building command-line application. Command-line Application Development asciimatics - Cross-platform, full-screen terminal package (i.e. mouse/keyboard input and coloured, positioned text output) complete with high-level API for complex animations and special effects. cement - CLI Application Framework for Python. click - A package for creating beautiful command line interfaces in a composable way. cliff - A framework for creating command-line programs with multi-level commands. clint - Python Command-line Application Tools. colorama - Cross-platform colored terminal text. docopt - Pythonic command line arguments parser. Gooey - Turn command line programs into a full GUI application with one line Python-Fire - A library for creating command line interfaces (CLIs) from absolutely any Python object. python-prompt-toolkit - A Library for building powerful interactive command lines. Productivity Tools aws-cli - A universal command-line interface for Amazon Web Services. bashplotlib - Making basic plots in the terminal. caniusepython3 - Determine what projects are blocking you from porting to Python 3. cookiecutter - A command-line utility that creates projects from cookiecutters (project templates). doitlive - A tool for live presentations in the terminal. howdoi - Instant coding answers via the command line. httpie - A command line HTTP client, a user-friendly cURL replacement. mycli - A Terminal Client for MySQL with AutoCompletion and Syntax Highlighting. PathPicker - Select files out of bash output. percol - Adds flavor of interactive selection to the traditional pipe concept on UNIX. pgcli - Postgres CLI with autocompletion and syntax highlighting. SAWS - A Supercharged AWS CLI. thefuck - Correcting your previous console command. try - A dead simple CLI to try out python packages - It’s never been easier. CompatibilityLibraries for migrating from Python 2 to 3. Python-Future - The missing compatibility layer between Python 2 and Python 3. Python-Modernize - Modernizes Python code for eventual Python 3 migration. Six - Python 2 and 3 compatibility utilities. Computer VisionLibraries for computer vision. OpenCV - Open Source Computer Vision Library. pyocr - A wrapper for Tesseract and Cuneiform. pytesseract - Another wrapper for Google Tesseract OCR. SimpleCV - An open source framework for building computer vision applications. Concurrency and ParallelismLibraries for concurrent and parallel execution. eventlet - Asynchronous framework with WSGI support. gevent - A coroutine-based Python networking library that uses greenlet. multiprocessing - (Python standard library) Process-based “threading” interface. threading - (Python standard library) Higher-level threading interface. Tomorrow - Magic decorator syntax for asynchronous code. uvloop - Ultra fast implementation of asyncio event loop on top of libuv. ConfigurationLibraries for storing and parsing configuration options. config - Hierarchical config from the author of logging. ConfigObj - INI file parser with validation. ConfigParser - (Python standard library) INI file parser. profig - Config from multiple formats with value conversion. python-decouple - Strict separation of settings from code. Cryptography cryptography - A package designed to expose cryptographic primitives and recipes to Python developers. hashids - Implementation of hashids in Python. Paramiko - A Python (2.6+, 3.3+) implementation of the SSHv2 protocol, providing both client and server functionality. Passlib - Secure password storage/hashing library, very high level. PyNacl - Python binding to the Networking and Cryptography (NaCl) library. Data AnalysisLibraries for data analyzing. Blaze - NumPy and Pandas interface to Big Data. Open Mining - Business Intelligence (BI) in Pandas interface. Orange - Data mining, data visualization, analysis and machine learning through visual programming or scripts. Pandas - A library providing high-performance, easy-to-use data structures and data analysis tools. Data ValidationLibraries for validating data. Used for forms in many cases. Cerberus - A lightweight and extensible data validation library. colander - Validating and deserializing data obtained via XML, JSON, an HTML form post. jsonschema - An implementation of JSON Schema for Python. schema - A library for validating Python data structures. Schematics - Data Structure Validation. valideer - Lightweight extensible data validation and adaptation library. voluptuous - A Python data validation library. Data VisualizationLibraries for visualizing data. See: awesome-javascript. Altair - Declarative statistical visualization library for Python. Bokeh - Interactive Web Plotting for Python. ggplot - Same API as ggplot2 for R. Matplotlib - A Python 2D plotting library. Pygal - A Python SVG Charts Creator. PyGraphviz - Python interface to Graphviz. PyQtGraph - Interactive and realtime 2D/3D/Image plotting and science/engineering widgets. Seaborn - Statistical data visualization using Matplotlib. VisPy - High-performance scientific visualization based on OpenGL. DatabaseDatabases implemented in Python. pickleDB - A simple and lightweight key-value store for Python. PipelineDB - The Streaming SQL Database. TinyDB - A tiny, document-oriented database. ZODB - A native object database for Python. A key-value and object graph database. Database DriversLibraries for connecting and operating databases. MySQL - awesome-mysql mysql-python - The MySQL database connector for Python. mysqlclient - mysql-python fork supporting Python 3. oursql - A better MySQL connector with support for native prepared statements and BLOBs. PyMySQL - Pure Python MySQL driver compatible to mysql-python. PostgreSQL psycopg2 - The most popular PostgreSQL adapter for Python. queries - A wrapper of the psycopg2 library for interacting with PostgreSQL. txpostgres - Twisted based asynchronous driver for PostgreSQL. Other Relational Databases apsw - Another Python SQLite wrapper. dataset - Store Python dicts in a database - works with SQLite, MySQL, and PostgreSQL. pymssql - A simple database interface to Microsoft SQL Server. NoSQL Databases cassandra-python-driver - Python driver for Cassandra. HappyBase - A developer-friendly library for Apache HBase. Plyvel - A fast and feature-rich Python interface to LevelDB. py2neo - Python wrapper client for Neo4j’s restful interface. pycassa - Python Thrift driver for Cassandra. PyMongo - The official Python client for MongoDB. redis-py - The Redis Python Client. telephus - Twisted based client for Cassandra. txRedis - Twisted based client for Redis. Date and TimeLibraries for working with dates and times. arrow - Better dates &amp; times for Python. Chronyk - A Python 3 library for parsing human-written times and dates. dateutil - Extensions to the standard Python datetime module. delorean - A library for clearing up the inconvenient truths that arise dealing with datetimes. moment - A Python library for dealing with dates/times. Inspired by Moment.js. Pendulum - Python datetimes made easy. PyTime - A easy-use Python module which aims to operate date/time/datetime by string. pytz - World timezone definitions, modern and historical. Brings the tz database into Python. when.py - Providing user-friendly functions to help perform common date and time actions. Debugging ToolsLibraries for debugging code. pdb-like Debugger ipdb - IPython-enabled pdb. pdb++ - Another drop-in replacement for pdb. pudb - A full-screen, console-based Python debugger. remote-pdb - Remote vanilla PDB (over TCP sockets). wdb - An improbable web debugger through WebSockets. Profiler line_profiler - Line-by-line profiling. memory_profiler - Monitor Memory usage of Python code. profiling - An interactive Python profiler. vprof - Visual Python profiler. Others django-debug-toolbar - Display various debug information for Django. django-devserver - A drop-in replacement for Django’s runserver. flask-debugtoolbar - A port of the django-debug-toolbar to flask. hunter - Hunter is a flexible code tracing toolkit. lptrace - strace for Python programs. manhole - Debug service that will accept unix domain socket connections and present the stacktraces for all threads and an interactive prompt. pyelftools - Parsing and analyzing ELF files and DWARF debugging information. pyringe - Debugger capable of attaching to and injecting code into Python processes. Deep LearningFrameworks for Neural Networks and Deep Learning. See: awesome-deep-learning. Caffe - A fast open framework for deep learning.. Keras - A high-level neural networks library and capable of running on top of either TensorFlow or Theano. MXNet - A deep learning framework designed for both efficiency and flexibility. Neupy - Running and testing different Artificial Neural Networks algorithms. Pytorch - Tensors and Dynamic neural networks in Python with strong GPU acceleration. TensorFlow - The most popular Deep Learning framework created by Google. Theano - A library for fast numerical computation. DevOps ToolsSoftware and libraries for DevOps. Ansible - A radically simple IT automation platform. Cloud-Init - A multi-distribution package that handles early initialization of a cloud instance. cuisine - Chef-like functionality for Fabric. Docker Compose - Fast, isolated development environments using Docker. Fabric - A simple, Pythonic tool for remote execution and deployment. Fabtools - Tools for writing awesome Fabric files. honcho - A Python clone of Foreman, for managing Procfile-based applications. OpenStack - Open source software for building private and public clouds. pexpect - Controlling interactive programs in a pseudo-terminal like GNU expect. psutil - A cross-platform process and system utilities module. SaltStack - Infrastructure automation and management system. supervisor - Supervisor process control system for UNIX. DistributionLibraries to create packaged executables for release distribution. dh-virtualenv - Build and distribute a virtualenv as a Debian package. Nuitka - Compile scripts, modules, packages to an executable or extension module. py2app - Freezes Python scripts (Mac OS X). py2exe - Freezes Python scripts (Windows). PyInstaller - Converts Python programs into stand-alone executables (cross-platform). pynsist - A tool to build Windows installers, installers bundle Python itself. DocumentationLibraries for generating project documentation. Sphinx - Python Documentation generator. awesome-sphinxdoc MkDocs - Markdown friendly documentation generator. pdoc - Epydoc replacement to auto generate API documentation for Python libraries. Pycco - The literate-programming-style documentation generator. DownloaderLibraries for downloading. s3cmd - A command line tool for managing Amazon S3 and CloudFront. s4cmd - Super S3 command line tool, good for higher performance. you-get - A YouTube/Youku/Niconico video downloader written in Python 3. youtube-dl - A small command-line program to download videos from YouTube. E-commerceFrameworks and libraries for e-commerce and payments. alipay - Unofficial Alipay API for Python. Cartridge - A shopping cart app built using the Mezzanine. django-oscar - An open-source e-commerce framework for Django. django-shop - A Django based shop system. merchant - A Django app to accept payments from various payment processors. money - Money class with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution. python-currencies - Display money format and its filthy currencies. forex-python - Foreign exchange rates, Bitcoin price index and currency conversion. shoop - An open source E-Commerce platform based on Django. Editor Plugins and IDEs Emacs Elpy - Emacs Python Development Environment. Sublime Text Anaconda - Anaconda turns your Sublime Text 3 in a full featured Python development IDE. SublimeJEDI - A Sublime Text plugin to the awesome auto-complete library Jedi. Vim Jedi-vim - Vim bindings for the Jedi auto-completion library for Python. Python-mode - An all in one plugin for turning Vim into a Python IDE. YouCompleteMe - Includes Jedi-based completion engine for Python. Visual Studio PTVS - Python Tools for Visual Studio. Visual Studio Code Python - An extension with rich support for the Python language, with features including linting, IntelliSense, formatting, refactoring, debugging, unit tests, and jupyter support. Magic Python - Cutting edge Python syntax highlighter for Sublime Text, Atom, and Visual Studio Code. Used by GitHub to highlight your Python code! IDE LiClipse - Free polyglot IDE based on Eclipse. Uses PyDev for Python support. PyCharm - Commercial Python IDE by JetBrains. Has free community edition available. Spyder - Open Source Python IDE. EmailLibraries for sending and parsing email. envelopes - Mailing for human beings. flanker - A email address and Mime parsing library. imbox - Python IMAP for Humans. inbox.py - Python SMTP Server for Humans. lamson - Pythonic SMTP Application Server. Marrow Mailer - High-performance extensible mail delivery framework. modoboa - A mail hosting and management platform including a modern and simplified Web UI. Nylas Sync Engine - Providing a RESTful API on top of a powerful email sync platform. yagmail - Yet another Gmail/SMTP client. Environment ManagementLibraries for Python version and environment management. p - Dead simple interactive Python version management. pyenv - Simple Python version management. venv - (Python standard library in Python 3.3+) Creating lightweight virtual environments. virtualenv - A tool to create isolated Python environments. virtualenvwrapper - A set of extensions to virtualenv. FilesLibraries for file manipulation and MIME type detection. imghdr - (Python standard library) Determine the type of an image. mimetypes - (Python standard library) Map filenames to MIME types. path.py - A module wrapper for os.path. pathlib - (Python standard library in Python 3.4+) An cross-platform, object-oriented path library. python-magic - A Python interface to the libmagic file type identification library. Unipath - An object-oriented approach to file/directory operations. watchdog - API and shell utilities to monitor file system events. Foreign Function InterfaceLibraries for providing foreign function interface. cffi - Foreign Function Interface for Python calling C code. ctypes - (Python standard library) Foreign Function Interface for Python calling C code. PyCUDA - A Python wrapper for Nvidia’s CUDA API. SWIG - Simplified Wrapper and Interface Generator. FormsLibraries for working with forms. Deform - Python HTML form generation library influenced by the formish form generation library. django-bootstrap3 - Bootstrap 3 integration with Django. django-crispy-forms - A Django app which lets you create beautiful forms in a very elegant and DRY way. django-remote-forms - A platform independent Django form serializer. WTForms - A flexible forms validation and rendering library. Functional ProgrammingFunctional Programming with Python. CyToolz - Cython implementation of Toolz: High performance functional utilities. fn.py - Functional programming in Python: implementation of missing features to enjoy FP. funcy - A fancy and practical functional tools. Toolz - A collection of functional utilities for iterators, functions, and dictionaries. GUILibraries for working with graphical user interface applications. curses - Built-in wrapper for ncurses used to create terminal GUI applications. enaml - Creating beautiful user-interfaces with Declaratic Syntax like QML. Flexx - Flexx is a pure Python toolkit for creating GUI’s, that uses web technology for its rendering. kivy - A library for creating NUI applications, running on Windows, Linux, Mac OS X, Android and iOS. pyglet - A cross-platform windowing and multimedia library for Python. PyGObject - Python Bindings for GLib/GObject/GIO/GTK+ (GTK+3) PyQt - Python bindings for the Qt cross-platform application and UI framework, with support for both Qt v4 and Qt v5 frameworks. PySide - Python bindings for the Qt cross-platform application and UI framework, supporting the Qt v4 framework. pywebview - A lightweight cross-platform native wrapper around a webview component that allows to display HTML content in its own native dedicated window Tkinter - Tkinter is Python’s de-facto standard GUI package. Toga - A Python native, OS native GUI toolkit. urwid - A library for creating terminal GUI applications with strong support for widgets, events, rich colors, etc. wxPython - A blending of the wxWidgets C++ class library with the Python. Game DevelopmentAwesome game development libraries. Cocos2d - cocos2d is a framework for building 2D games, demos, and other graphical/interactive applications. It is based on pyglet. Panda3D - 3D game engine developed by Disney and maintained by Carnegie Mellon’s Entertainment Technology Center. Written in C++, completely wrapped in Python. Pygame - Pygame is a set of Python modules designed for writing games. PyOgre - Python bindings for the Ogre 3D render engine, can be used for games, simulations, anything 3D. PyOpenGL - Python ctypes bindings for OpenGL and it’s related APIs. PySDL2 - A ctypes based wrapper for the SDL2 library. RenPy - A Visual Novel engine. GeolocationLibraries for geocoding addresses and working with latitudes and longitudes. django-countries - A Django app that provides country choices for use with forms, flag icons static files, and a country field for models. GeoDjango - A world-class geographic web framework. GeoIP - Python API for MaxMind GeoIP Legacy Database. geojson - Python bindings and utilities for GeoJSON. geopy - Python Geocoding Toolbox. pygeoip - Pure Python GeoIP API. HTML ManipulationLibraries for working with HTML and XML. BeautifulSoup - Providing Pythonic idioms for iterating, searching, and modifying HTML or XML. bleach - A whitelist-based HTML sanitization and text linkification library. cssutils - A CSS library for Python. html5lib - A standards-compliant library for parsing and serializing HTML documents and fragments. lxml - A very fast, easy-to-use and versatile library for handling HTML and XML. MarkupSafe - Implements a XML/HTML/XHTML Markup safe string for Python. pyquery - A jQuery-like library for parsing HTML. untangle - Converts XML documents to Python objects for easy access. WeasyPrint - A visual rendering engine for HTML and CSS that can export to PDF. xmldataset - Simple XML Parsing. xmltodict - Working with XML feel like you are working with JSON. HTTPLibraries for working with HTTP. grequests - requests + gevent for asynchronous HTTP requests. httplib2 - Comprehensive HTTP client library. requests - HTTP Requests for Humans™. treq - Python requests like API built on top of Twisted’s HTTP client. urllib3 - A HTTP library with thread-safe connection pooling, file post support, sanity friendly. HardwareLibraries for programming with hardware. ino - Command line toolkit for working with Arduino. Pingo - Pingo provides a uniform API to program devices like the Raspberry Pi, pcDuino, Intel Galileo, etc. Pyro - Python Robotics. PyUserInput - A module for cross-platform control of the mouse and keyboard. scapy - A brilliant packet manipulation library. wifi - A Python library and command line tool for working with WiFi on Linux. ImageryLibraries for manipulating images. hmap - Image histogram remapping. imgSeek - A project for searching a collection of images using visual similarity. nude.py - Nudity detection. pagan - Retro identicon (Avatar) generation based on input string and hash. pillow - Pillow is the friendly PIL fork. pyBarcode - Create barcodes in Python without needing PIL. pygram - Instagram-like image filters. python-qrcode - A pure Python QR Code generator. Quads - Computer art based on quadtrees. scikit-image - A Python library for (scientific) image processing. thumbor - A smart imaging service. It enables on-demand crop, re-sizing and flipping of images. wand - Python bindings for MagickWand, C API for ImageMagick. ImplementationsImplementations of Python. CLPython - Implementation of the Python programming language written in Common Lisp. CPython - Default, most widely used implementation of the Python programming language written in C. Optimizing Static Compiler for Python. Uses type mixins to compile Python into C or C++ modules resulting in large performance gains. Grumpy - More compiler than interpreter as more powerful CPython2.7 replacement (alpha). IronPython - Implementation of the Python programming language written in C# targeting the .NET Framework and Mono. Jython - Implementation of Python programming language written in Java for the Java virtual machine (JVM). MicroPython - MicroPython - a lean and efficient Python programming language implementation for microcontrollers and constrained systems Numba - Python JIT complier to LLVM aimed at scientific Python. PeachPy - x86-64 assembler embedded in Python. Can be used as inline assembler for Python or as a stand-alone assembler for Windows, Linux, OS X, Native Client and Go. Pyjion - A JIT for Python based upon CoreCLR. PyPy - Implementation of the Python programming language written in RPython and translated into C. PyPy focuses on speed, efficiency and compatibility with the original CPython interpreter. The interpreter uses black magic to make Python very fast without having to add in additional type information. PySec - Hardened version of python that makes it easier for security professionals and developers to write applications more resilient to attacks and manipulations. Pyston - A Python implementation built using LLVM and modern JIT techniques with the goal of achieving good performance. Stackless Python - An enhanced version of the Python programming language which allows programmers to reap the benefits of thread-based programming without the performance and complexity problems associated with conventional threads. Interactive InterpreterInteractive Python interpreters (REPL). bpython - A fancy interface to the Python interpreter. Jupyter Notebook (IPython) - A rich toolkit to help you make the most out of using Python interactively. ptpython - Advanced Python REPL built on top of the python-prompt-toolkit. InternationalizationLibraries for working with i18n. Babel - An internationalization library for Python. PyICU - A wrapper of International Components for Unicode C++ library (ICU). Job SchedulerLibraries for scheduling jobs. APScheduler - A light but powerful in-process task scheduler that lets you schedule functions. django-schedule - A calendaring app for Django. doit - A task runner and build tool. gunnery - Multipurpose task execution tool for distributed systems with web-based interface. Joblib - A set of tools to provide lightweight pipelining in Python. Plan - Writing crontab file in Python like a charm. schedule - Python job scheduling for humans. Spiff - A powerful workflow engine implemented in pure Python. TaskFlow - A Python library that helps to make task execution easy, consistent and reliable. LoggingLibraries for generating and working with logs. Eliot - Logging for complex &amp; distributed systems. logbook - Logging replacement for Python. logging - (Python standard library) Logging facility for Python. Raven - The Python client for Sentry. Sentry - A realtime logging and aggregation server. Machine LearningLibraries for Machine Learning. See: awesome-machine-learning. gensim - Topic Modelling for Humans. LightFM - A Python implementation of a number of popular recommendation algorithms. NuPIC - Numenta Platform for Intelligent Computing. scikit-learn - The most popular Python library for Machine Learning. Spark ML - Apache Spark‘s scalable Machine Learning library. surprise - A scikit for building and analyzing recommender systems. vowpal_porpoise - A lightweight Python wrapper for Vowpal Wabbit. xgboost - A scalable, portable, and distributed gradient boosting library. MapReduceFrameworks and libraries for MapReduce. dpark - Python clone of Spark, a MapReduce alike framework in Python. dumbo - Python module that allows one to easily write and run Hadoop programs. luigi - A module that helps you build complex pipelines of batch jobs. mrjob - Run MapReduce jobs on Hadoop or Amazon Web Services. PySpark - The Spark Python API. streamparse - Run Python code against real-time streams of data. Integrates with Apache Storm. Microsoft WindowsPython programming on Microsoft Windows. Python(x,y) - Scientific-applications-oriented Python Distribution based on Qt and Spyder. pythonlibs - Unofficial Windows binaries for Python extension packages. PythonNet - Python Integration with the .NET Common Language Runtime (CLR). PyWin32 - Python Extensions for Windows. WinPython - Portable development environment for Windows 7/8. MiscellaneousUseful libraries or tools that don’t fit in the categories above. blinker - A fast Python in-process signal/event dispatching system. itsdangerous - Various helpers to pass trusted data to untrusted environments. pluginbase - A simple but flexible plugin system for Python. Pychievements - A framework for creating and tracking achievements. Tryton - A general purpose business framework. Natural Language ProcessingLibraries for working with human languages. Jieba - Chinese text segmentation. langid.py - Stand-alone language identification system. NLTK - A leading platform for building Python programs to work with human language data. Pattern - A web mining module for the Python. SnowNLP - A library for processing Chinese text. spaCy - A library for industrial-strength natural language processing in Python and Cython. TextBlob - Providing a consistent API for diving into common NLP tasks. TextGrocery - A simple, efficient short-text classification tool based on LibLinear and Jieba. Network VirtualizationTools and libraries for Virtual Networking and SDN (Software Defined Networking). Mininet - A popular network emulator and API written in Python. POX - An open source development platform for Python-based Software Defined Networking (SDN) control applications, such as OpenFlow SDN controllers. Pyretic - A member of the Frenetic family of SDN programming languages that provides powerful abstractions over network switches or emulators. SDX Platform - SDN based IXP implementation that leverages Mininet, POX and Pyretic. NetworkingLibraries for networking programming. asyncio - (Python standard library) Asynchronous I/O, event loop, coroutines and tasks. diesel - Greenlet-based event I/O Framework for Python. pulsar - Event-driven concurrent framework for Python. pyzmq - A Python wrapper for the ZeroMQ message library. Twisted - An event-driven networking engine. txZMQ - Twisted based wrapper for the ZeroMQ message library. News FeedLibraries for building user’s activities. django-activity-stream - Generating generic activity streams from the actions on your site. Stream-Framework - Building newsfeed and notification systems using Cassandra and Redis. ORMLibraries that implement Object-Relational Mapping or data mapping techniques. Relational Databases Django Models - A part of Django. SQLAlchemy - The Python SQL Toolkit and Object Relational Mapper. awesome-sqlalchemy Orator - The Orator ORM provides a simple yet beautiful ActiveRecord implementation. Peewee - A small, expressive ORM. PonyORM - ORM that provides a generator-oriented interface to SQL. pyDAL - A pure Python Database Abstraction Layer. python-sql - Write SQL queries pythonically. NoSQL Databases django-mongodb-engine - Django MongoDB Backend. flywheel - Object mapper for Amazon DynamoDB. hot-redis - Rich Python data types for Redis. MongoEngine - A Python Object-Document-Mapper for working with MongoDB. PynamoDB - A Pythonic interface for Amazon DynamoDB. redisco - A Python Library for Simple Models and Containers Persisted in Redis. Others butterdb - A Python ORM for Google Drive Spreadsheets. dataset - A JSON-based database. Package ManagementLibraries for package and dependency management. pip - The Python package and dependency manager. Python Package Index conda - Cross-platform, Python-agnostic binary package manager. Curdling - Curdling is a command line tool for managing Python packages. pip-tools - A set of tools to keep your pinned Python dependencies fresh. wheel - The new standard of Python distribution and are intended to replace eggs. Package RepositoriesLocal PyPI repository server and proxies. warehouse - Next generation Python Package Repository (PyPI). Warehouse bandersnatch - PyPI mirroring tool provided by Python Packaging Authority (PyPA). devpi - PyPI server and packaging/testing/release tool. localshop - Local PyPI server (custom packages and auto-mirroring of pypi). PermissionsLibraries that allow or deny users access to data or functionality. Carteblanche - Module to align code with thoughts of users and designers. Also magically handles navigation and permissions. django-guardian - Implementation of per object permissions for Django 1.2+ django-rules - A tiny but powerful app providing object-level permissions to Django, without requiring a database. ProcessesLibraries for starting and communicating with OS processes. envoy - Python subprocess for Humans™. sarge - Yet another wrapper for subprocess. sh - A full-fledged subprocess replacement for Python. QueueLibraries for working with event and task queues. celery - An asynchronous task queue/job queue based on distributed message passing. huey - Little multi-threaded task queue. mrq - Mr. Queue - A distributed worker task queue in Python using Redis &amp; gevent. rq - Simple job queues for Python. simpleq - A simple, infinitely scalable, Amazon SQS based queue. RESTful APILibraries for developing RESTful APIs. Django django-formapi - Create JSON APIs with Django’s form validation. django-rest-framework - A powerful and flexible toolkit to build web APIs. django-tastypie - Creating delicious APIs for Django apps. Flask eve - REST API framework powered by Flask, MongoDB and good intentions. flask-api-utils - Taking care of API representation and authentication for Flask. flask-api - Browsable Web APIs for Flask. flask-restful - Quickly building REST APIs for Flask. flask-restless - Generating RESTful APIs for database models defined with SQLAlchemy. Pyramid cornice - A RESTful framework for Pyramid. Framework agnostic falcon - A high-performance framework for building cloud APIs and web app backends. hug - A Python3 framework for cleanly exposing APIs over HTTP and the Command Line with automatic documentation and validation. restless - Framework agnostic REST framework based on lessons learned from Tastypie. ripozo - Quickly creating REST/HATEOAS/Hypermedia APIs. sandman - Automated REST APIs for existing database-driven systems. RPC ServersRPC-compatible servers. SimpleJSONRPCServer - This library is an implementation of the JSON-RPC specification. SimpleXMLRPCServer - (Python standard library) Simple XML-RPC server implementation, single-threaded. zeroRPC - zerorpc is a flexible RPC implementation based on ZeroMQ and MessagePack. ScienceLibraries for scientific computing. astropy - A community Python library for Astronomy. bcbio-nextgen - Providing best-practice pipelines for fully automated high throughput sequencing analysis. bccb - Collection of useful code related to biological analysis. Biopython - Biopython is a set of freely available tools for biological computation. cclib - A library for parsing and interpreting the results of computational chemistry packages. NetworkX - A high-productivity software for complex networks. NIPY - A collection of neuroimaging toolkits. NumPy - A fundamental package for scientific computing with Python. Open Babel - A chemical toolbox designed to speak the many languages of chemical data. ObsPy - A Python toolbox for seismology. PyDy - Short for Python Dynamics, used to assist with workflow in the modeling of dynamic motion. PyMC - Markov Chain Monte Carlo sampling toolkit. RDKit - Cheminformatics and Machine Learning Software. SciPy - A Python-based ecosystem of open-source software for mathematics, science, and engineering. statsmodels - Statistical modeling and econometrics in Python. SymPy - A Python library for symbolic mathematics. Zipline - A Pythonic algorithmic trading library. SimPy - A process-based discrete-event simulation framework. SearchLibraries and software for indexing and performing search queries on data. django-haystack - Modular search for Django. elasticsearch-dsl-py - The official high-level Python client for Elasticsearch. elasticsearch-py - The official low-level Python client for Elasticsearch. esengine - ElasticSearch ODM (Object Document Mapper) for Python. pysolr - A lightweight Python wrapper for Apache Solr (incl. SolrCloud awareness). solrpy - A Python client for solr. Whoosh - A fast, pure Python search engine library. SerializationLibraries for serializing complex data types marshmallow - marshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes. Serverless FrameworksFrameworks for developing serverless Python code. apex - Build, deploy, and manage AWS Lambda functions with ease. python-lambda - A toolkit for developing and deploying Python code in AWS Lambda. Zappa - A tool for deploying WSGI applications on AWS Lambda and API Gateway. Specific Formats ProcessingLibraries for parsing and manipulating specific text formats. General tablib - A module for Tabular Datasets in XLS, CSV, JSON, YAML. Office Marmir - Takes Python data structures and turns them into spreadsheets. openpyxl - A library for reading and writing Excel 2010 xlsx/xlsm/xltx/xltm files. pyexcel - Providing one API for reading, manipulating and writing csv, ods, xls, xlsx and xlsm files. python-docx - Reads, queries and modifies Microsoft Word 2007/2008 docx files. relatorio - Templating OpenDocument files. unoconv - Convert between any document format supported by LibreOffice/OpenOffice. XlsxWriter - A Python module for creating Excel .xlsx files. xlwings - A BSD-licensed library that makes it easy to call Python from Excel and vice versa. xlwt / xlrd - Writing and reading data and formatting information from Excel files. PDF PDFMiner - A tool for extracting information from PDF documents. PyPDF2 - A library capable of splitting, merging and transforming PDF pages. ReportLab - Allowing Rapid creation of rich PDF documents. Markdown Mistune - Fastest and full featured pure Python parsers of Markdown. Python-Markdown - A Python implementation of John Gruber’s Markdown. YAML PyYAML - YAML implementations for Python. CSV csvkit - Utilities for converting to and working with CSV. Archive unp - A command line tool that can unpack archives easily. Static Site GeneratorStatic site generator is a software that takes some text + templates as input and produces HTML files on the output. Cactus - Static site generator for designers. Hyde - Jinja2-based static web site generator. Lektor - An easy to use static CMS and blog engine. Nikola - A static website and blog generator. Pelican - Uses Markdown or ReST for content and Jinja 2 for themes. Supports DVCS, Disqus. AGPL. Tinkerer - Tinkerer is a blogging engine/.static website generator powered by Sphinx. TaggingLibraries for tagging items. django-taggit - Simple tagging for Django. Template EngineLibraries and tools for templating and lexing. Genshi - Python templating toolkit for generation of web-aware output. Jinja2 - A modern and designer friendly templating language. Mako - Hyperfast and lightweight templating for the Python platform. TestingLibraries for testing codebases and generating test data. Testing Frameworks hypothesis - Hypothesis is an advanced Quickcheck style property based testing library. mamba - The definitive testing tool for Python. Born under the banner of BDD. nose - A nicer unittest for Python. nose2 - The successor to nose, based on unittest2. pytest - A mature full-featured Python testing tool. Robot Framework - A generic test automation framework. unittest - (Python standard library) Unit testing framework. Test Runners green - A clean, colorful test runner. tox - Auto builds and tests distributions in multiple Python versions GUI / Web Testing locust - Scalable user load testing tool written in Python. PyAutoGUI - PyAutoGUI is a cross-platform GUI automation Python module for human beings. Selenium - Python bindings for Selenium WebDriver. sixpack - A language-agnostic A/B Testing framework. splinter - Open source tool for testing web applications. Mock doublex - Powerful test doubles framework for Python. freezegun - Travel through time by mocking the datetime module. httmock - A mocking library for requests for Python 2.6+ and 3.2+. httpretty - HTTP request mock tool for Python. mock - (Python standard library) A mocking and patching library. responses - A utility library for mocking out the requests Python library. VCR.py - Record and replay HTTP interactions on your tests. Object Factories factory_boy - A test fixtures replacement for Python. mixer - Another fixtures replacement. Supported Django, Flask, SQLAlchemy, Peewee and etc. model_mommy - Creating random fixtures for testing in Django. Code Coverage coverage - Code coverage measurement. Fake Data church - is a Python library that help you generate fake data. fake2db - Fake database generator. faker - A Python package that generates fake data. radar - Generate random datetime / time. Error Handler FuckIt.py - FuckIt.py uses state-of-the-art technology to make sure your Python code runs whether it has any right to or not. Text ProcessingLibraries for parsing and manipulating plain texts. General chardet - Python 2/3 compatible character encoding detector. difflib - (Python standard library) Helpers for computing deltas. ftfy - Makes Unicode text less broken and more consistent automagically. fuzzywuzzy - Fuzzy String Matching. Levenshtein - Fast computation of Levenshtein distance and string similarity. pangu.py - Spacing texts for CJK and alphanumerics. pyfiglet - An implementation of figlet written in Python. shortuuid - A generator library for concise, unambiguous and URL-safe UUIDs. unidecode - ASCII transliterations of Unicode text. uniout - Print readable chars instead of the escaped string. xpinyin - A library to translate Chinese hanzi (漢字) to pinyin (拼音). Slugify awesome-slugify - A Python slugify library that can preserve unicode. python-slugify - A Python slugify library that translates unicode to ASCII. unicode-slugify - A slugifier that generates unicode slugs with Django as a dependency. Parser phonenumbers - Parsing, formatting, storing and validating international phone numbers. PLY - Implementation of lex and yacc parsing tools for Python Pygments - A generic syntax highlighter. pyparsing - A general purpose framework for generating parsers. python-nameparser - Parsing human names into their individual components. python-user-agents - Browser user agent parser. sqlparse - A non-validating SQL parser. Third-party APIsLibraries for accessing third party services APIs. See: List of Python API Wrappers and Libraries. apache-libcloud - One Python library for all clouds. boto3 - Python interface to Amazon Web Services. django-wordpress - WordPress models and views for Django. facebook-sdk - Facebook Platform Python SDK. facepy - Facepy makes it really easy to interact with Facebook’s Graph API gmail - A Pythonic interface for Gmail. google-api-python-client - Google APIs Client Library for Python. gspread - Google Spreadsheets Python API. twython - A Python wrapper for the Twitter API. URL ManipulationLibraries for parsing URLs. furl - A small Python library that makes parsing and manipulating URLs easy. purl - A simple, immutable URL class with a clean API for interrogation and manipulation. pyshorteners - A pure Python URL shortening lib. short_url - Python implementation for generating Tiny URL and bit.ly-like URLs. webargs - A friendly library for parsing HTTP request arguments, with built-in support for popular web frameworks, including Flask, Django, Bottle, Tornado, and Pyramid. VideoLibraries for manipulating video and GIFs. moviepy - A module for script-based movie editing with many formats, including animated GIFs. scikit-video - Video processing routines for SciPy. WSGI ServersWSGI-compatible web servers. bjoern - Asynchronous, very fast and written in C. fapws3 - Asynchronous (network side only), written in C. gunicorn - Pre-forked, partly written in C. meinheld - Asynchronous, partly written in C. netius - Asynchronous, very fast. paste - Multi-threaded, stable, tried and tested. rocket - Multi-threaded. uWSGI - A project aims at developing a full stack for building hosting services, written in C. waitress - Multi-threaded, powers Pyramid. Werkzeug - A WSGI utility library for Python that powers Flask and can easily be embedded into your own projects. Web Content ExtractingLibraries for extracting web contents. Haul - An Extensible Image Crawler. html2text - Convert HTML to Markdown-formatted text. lassie - Web Content Retrieval for Humans. micawber - A small library for extracting rich content from URLs. newspaper - News extraction, article extraction and content curation in Python. opengraph - A Python module to parse the Open Graph Protocol python-goose - HTML Content/Article Extractor. python-readability - Fast Python port of arc90’s readability tool. sanitize - Bringing sanity to world of messed-up data. sumy - A module for automatic summarization of text documents and HTML pages. textract - Extract text from any document, Word, PowerPoint, PDFs, etc. Web CrawlingLibraries for scraping websites. cola - A distributed crawling framework. Demiurge - PyQuery-based scraping micro-framework. feedparser - Universal feed parser. Grab - Site scraping framework. MechanicalSoup - A Python library for automating interaction with websites. portia - Visual scraping for Scrapy. pyspider - A powerful spider system. RoboBrowser - A simple, Pythonic library for browsing the web without a standalone web browser. Scrapy - A fast high-level screen scraping and web crawling framework. Web FrameworksFull stack web frameworks. Bottle - A fast, simple and lightweight WSGI micro web-framework. CherryPy - A minimalist Python web framework, HTTP/1.1-compliant and WSGI thread-pooled. Django - The most popular web framework in Python. awesome-django Flask - A microframework for Python. awesome-flask Pyramid - A small, fast, down-to-earth, open source Python web framework. awesome-pyramid Sanic - Web server that’s written to go fast. Tornado - A Web framework and asynchronous networking library. TurboGears - A microframework that can scale up to a full stack solution. Web2py - Full-stack enterprise framework for secure database-driven web-based applications. GitHub Web2py WebSocketLibraries for working with WebSocket. AutobahnPython - WebSocket &amp; WAMP for Python on Twisted and asyncio. Crossbar - Open-source Unified Application Router (Websocket &amp; WAMP for Python on Autobahn). django-socketio - WebSockets for Django. WebSocket-for-Python - WebSocket client and server library for Python 2 and 3 as well as PyPy. ServicesOnline tools and APIs to simplify development. Continuous IntegrationSee: awesome-CIandCD. CircleCI - A CI service that can run very fast parallel testing. (GitHub only) Travis CI - A popular CI service for your open source and private projects. (GitHub only) Vexor CI - A continuous integration tool for private apps with pay-per-minute billing model. Wercker - A Docker-based platform for building and deploying applications and microservices. Code Quality Codacy - Automated Code Review to ship better code, faster. Free for Open Source. Codecov - Code coverage dashboard. Landscape - Hosted continuous Python code metrics. QuantifiedCode - A data-driven, automated, continuous code review tool. ResourcesWhere to discover new Python libraries. Podcasts Podcast.init Talk Python To Me Python Bytes Twitter @codetengu @getpy @importpython @planetpython @pycoders @pypi @pythontrending @PythonWeekly @TalkPython Websites /r/CoolGithubProjects /r/Python Awesome Python @LibHunt Django Packages Full Stack Python PyPI Ranking Python 3 Wall of Superpowers Python Hackers Python ZEEF Python 开发社区 Trending Python repositories on GitHub today Weekly CodeTengu Weekly Import Python Newsletter Pycoder’s Weekly Python Weekly Python Bytes Other Awesome ListsList of lists. Monty awesome lists Python pycrumbs python-github-projects python_reference pythonidae ContributingYour contributions are always welcome! Please take a look at the contribution guidelines first. I will keep some pull requests open if I’m not sure whether those libraries are awesome, you could vote for them by adding :+1: to them. Pull requests will be merged when their votes reach 20.","categories":[],"tags":[],"keywords":[]},{"title":"pyDes one & triple","slug":"pyDes_one_triple","date":"2017-05-08T07:39:13.074Z","updated":"2017-05-08T07:54:27.587Z","comments":true,"path":"2017/05/08/pyDes_one_triple/","link":"","permalink":"http://yoursite.com/2017/05/08/pyDes_one_triple/","excerpt":"# Author: Todd Whiteman # Date: 16th March, 2009 # Verion: 2.0.0 # License: Public Domain - free to do as you wish # Homepage: http://twhiteman.netfirms.com/des.html # # This is a pure python implementation of the DES encryption algorithm. # It&apos;s pure python to avoid portability issues, since most DES # implementations are programmed in C (for performance reasons). # # Triple DES class is also implemented, utilising the DES base. Triple DES # is either DES-EDE3 with a 24 byte key, or DES-EDE2 with a 16 byte key. # # See the README.txt that should come with this python module for the # implementation methods used. # # Thanks to: # * David Broadwell for ideas, comments and suggestions. # * Mario Wolff for pointing out and debugging some triple des CBC errors. # * Santiago Palladino for providing the PKCS5 padding technique. # * Shaya for correcting the PAD_PKCS5 triple des CBC errors.","text":"# Author: Todd Whiteman # Date: 16th March, 2009 # Verion: 2.0.0 # License: Public Domain - free to do as you wish # Homepage: http://twhiteman.netfirms.com/des.html # # This is a pure python implementation of the DES encryption algorithm. # It&apos;s pure python to avoid portability issues, since most DES # implementations are programmed in C (for performance reasons). # # Triple DES class is also implemented, utilising the DES base. Triple DES # is either DES-EDE3 with a 24 byte key, or DES-EDE2 with a 16 byte key. # # See the README.txt that should come with this python module for the # implementation methods used. # # Thanks to: # * David Broadwell for ideas, comments and suggestions. # * Mario Wolff for pointing out and debugging some triple des CBC errors. # * Santiago Palladino for providing the PKCS5 padding technique. # * Shaya for correcting the PAD_PKCS5 triple des CBC errors. “””A pure python implementation of the DES and TRIPLE DES encryption algorithms. Class initializationpyDes.des(key, [mode], [IV], [pad], [padmode]) pyDes.triple_des(key, [mode], [IV], [pad], [padmode]) key -&gt; Bytes containing the encryption key. 8 bytes for DES, 16 or 24 bytes for Triple DES mode-&gt; Optional argument for encryption type, can be either pyDes.ECB (Electronic Code Book) or pyDes.CBC (Cypher Block Chaining) IV -&gt; Optional Initial Value bytes, must be supplied if using CBC mode. Length must be 8 bytes. pad -&gt; Optional argument, set the pad character (PAD_NORMAL) to use during all encrypt/decrpt operations done with this instance. padmode -&gt; Optional argument, set the padding mode (PAD_NORMAL or PAD_PKCS5) to use during all encrypt/decrpt operations done with this instance. I recommend to use PAD_PKCS5 padding, as then you never need to worry about any padding issues, as the padding can be removed unambiguously upon decrypting data that was encrypted using PAD_PKCS5 padmode. &lt;!--more--&gt; Common methods -------------- encrypt(data, [pad], [padmode]) decrypt(data, [pad], [padmode]) data-&gt; Bytes to be encrypted/decrypted pad -&gt; Optional argument. Only when using padmode of PAD_NORMAL. For encryption, adds this characters to the end of the data block when data is not a multiple of 8 bytes. For decryption, will remove the trailing characters that match this pad character from the last 8 bytes of the unencrypted data block. padmode -&gt; Optional argument, set the padding mode, must be one of PAD_NORMAL or PAD_PKCS5). Defaults to PAD_NORMAL. Examplefrom pyDes import * data = &quot;Please encrypt my data&quot; k = des(&quot;DESCRYPT&quot;, CBC, &quot;\\0\\0\\0\\0\\0\\0\\0\\0&quot;, pad=None, padmode=PAD_PKCS5) # For Python3, you&apos;ll need to use bytes, i.e.: # data = b&quot;Please encrypt my data&quot; # k = des(b&quot;DESCRYPT&quot;, CBC, b&quot;\\0\\0\\0\\0\\0\\0\\0\\0&quot;, pad=None, padmode=PAD_PKCS5) d = k.encrypt(data) print &quot;Encrypted: %r&quot; % d print &quot;Decrypted: %r&quot; % k.decrypt(d) assert k.decrypt(d, padmode=PAD_PKCS5) == data See the module source (pyDes.py) for more examples of use.You can also run the pyDes.py file without and arguments to see a simple test. Note: This code was not written for high-end systems needing a fast implementation, but rather a handy portable solution with small usage. &quot;&quot;&quot; import sys _pythonMajorVersion is used to handle Python2 and Python3 differences. _pythonMajorVersion = sys.version_info[0] Modes of crypting / cyphering ECB =0 CBC =1 # Modes of padding PAD_NORMAL = 1 PAD_PKCS5 = 2 # PAD_PKCS5: is a method that will unambiguously remove all padding #characters after decryption, when originally encrypted with #this padding mode. # For a good description of the PKCS5 padding technique, see: # http://www.faqs.org/rfcs/rfc1423.html # The base class shared by des and triple des. class _baseDes(object): def __init__(self, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL): if IV: IV = self._guardAgainstUnicode(IV) if pad: pad = self._guardAgainstUnicode(pad) self.block_size = 8 # Sanity checking of arguments. if pad and padmode == PAD_PKCS5: raise ValueError(&quot;Cannot use a pad character with PAD_PKCS5&quot;) if IV and len(IV) != self.block_size: raise ValueError(&quot;Invalid Initial Value (IV), must be a multiple of &quot; + str(self.block_size) + &quot; bytes&quot;) # Set the passed in variables self._mode = mode self._iv = IV self._padding = pad self._padmode = padmode def getKey(self): &quot;&quot;&quot;getKey() -&gt; bytes&quot;&quot;&quot; return self.__key def setKey(self, key): &quot;&quot;&quot;Will set the crypting key for this object.&quot;&quot;&quot; key = self._guardAgainstUnicode(key) self.__key = key def getMode(self): &quot;&quot;&quot;getMode() -&gt; pyDes.ECB or pyDes.CBC&quot;&quot;&quot; return self._mode def setMode(self, mode): &quot;&quot;&quot;Sets the type of crypting mode, pyDes.ECB or pyDes.CBC&quot;&quot;&quot; self._mode = mode def getPadding(self): &quot;&quot;&quot;getPadding() -&gt; bytes of length 1. Padding character.&quot;&quot;&quot; return self._padding def setPadding(self, pad): &quot;&quot;&quot;setPadding() -&gt; bytes of length 1. Padding character.&quot;&quot;&quot; if pad is not None: pad = self._guardAgainstUnicode(pad) self._padding = pad def getPadMode(self): &quot;&quot;&quot;getPadMode() -&gt; pyDes.PAD_NORMAL or pyDes.PAD_PKCS5&quot;&quot;&quot; return self._padmode def setPadMode(self, mode): &quot;&quot;&quot;Sets the type of padding mode, pyDes.PAD_NORMAL or pyDes.PAD_PKCS5&quot;&quot;&quot; self._padmode = mode def getIV(self): &quot;&quot;&quot;getIV() -&gt; bytes&quot;&quot;&quot; return self._iv def setIV(self, IV): &quot;&quot;&quot;Will set the Initial Value, used in conjunction with CBC mode&quot;&quot;&quot; if not IV or len(IV) != self.block_size: raise ValueError(&quot;Invalid Initial Value (IV), must be a multiple of &quot; + str(self.block_size) + &quot; bytes&quot;) IV = self._guardAgainstUnicode(IV) self._iv = IV def _padData(self, data, pad, padmode): # Pad data depending on the mode if padmode is None: # Get the default padding mode. padmode = self.getPadMode() if pad and padmode == PAD_PKCS5: raise ValueError(&quot;Cannot use a pad character with PAD_PKCS5&quot;) if padmode == PAD_NORMAL: if len(data) % self.block_size == 0: # No padding required. return data if not pad: # Get the default padding. pad = self.getPadding() if not pad: raise ValueError(&quot;Data must be a multiple of &quot; + str(self.block_size) + &quot; bytes in length. Use padmode=PAD_PKCS5 or set the pad character.&quot;) data += (self.block_size - (len(data) % self.block_size)) * pad elif padmode == PAD_PKCS5: pad_len = 8 - (len(data) % self.block_size) if _pythonMajorVersion &lt; 3: data += pad_len * chr(pad_len) else: data += bytes([pad_len] * pad_len) return data def _unpadData(self, data, pad, padmode): # Unpad data depending on the mode. if not data: return data if pad and padmode == PAD_PKCS5: raise ValueError(&quot;Cannot use a pad character with PAD_PKCS5&quot;) if padmode is None: # Get the default padding mode. padmode = self.getPadMode() if padmode == PAD_NORMAL: if not pad: # Get the default padding. pad = self.getPadding() if pad: data = data[:-self.block_size] + \\ data[-self.block_size:].rstrip(pad) elif padmode == PAD_PKCS5: if _pythonMajorVersion &lt; 3: pad_len = ord(data[-1]) else: pad_len = data[-1] data = data[:-pad_len] return data def _guardAgainstUnicode(self, data): # Only accept byte strings or ascii unicode values, otherwise # there is no way to correctly decode the data into bytes. if _pythonMajorVersion &lt; 3: if isinstance(data, unicode): raise ValueError(&quot;pyDes can only work with bytes, not Unicode strings.&quot;) else: if isinstance(data, str): # Only accept ascii unicode values. try: return data.encode(&apos;ascii&apos;) except UnicodeEncodeError: pass raise ValueError(&quot;pyDes can only work with encoded strings, not Unicode.&quot;) return data ############################################################################# DES############################################################################# class des(_baseDes): &quot;&quot;&quot;DES encryption/decrytpion class Supports ECB (Electronic Code Book) and CBC (Cypher Block Chaining) modes. pyDes.des(key,[mode], [IV]) key -&gt; Bytes containing the encryption key, must be exactly 8 bytes mode -&gt; Optional argument for encryption type, can be either pyDes.ECB (Electronic Code Book), pyDes.CBC (Cypher Block Chaining) IV -&gt; Optional Initial Value bytes, must be supplied if using CBC mode. Must be 8 bytes in length. pad -&gt; Optional argument, set the pad character (PAD_NORMAL) to use during all encrypt/decrpt operations done with this instance. padmode -&gt; Optional argument, set the padding mode (PAD_NORMAL or PAD_PKCS5) to use during all encrypt/decrpt operations done with this instance. &quot;&quot;&quot; # Permutation and translation tables for DES __pc1 = [56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3 ] # number left rotations of pc1 __left_rotations = [ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 ] # permuted choice key (table 2) __pc2 = [ 13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, 7, 15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47, 43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 ] # initial permutation IP __ip = [57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7, 56, 48, 40, 32, 24, 16, 8, 0, 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6 ] # Expansion table for turning 32 bit blocks into 48 bits __expansion_table = [ 31, 0, 1, 2, 3, 4, 3, 4, 5, 6, 7, 8, 7, 8, 9, 10, 11, 12, 11, 12, 13, 14, 15, 16, 15, 16, 17, 18, 19, 20, 19, 20, 21, 22, 23, 24, 23, 24, 25, 26, 27, 28, 27, 28, 29, 30, 31, 0 ] # The (in)famous S-boxes __sbox = [ # S1 [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13], # S2 [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9], # S3 [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12], # S4 [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14], # S5 [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3], # S6 [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13], # S7 [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12], # S8 [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11], ] # 32-bit permutation function P used on the output of the S-boxes __p = [ 15, 6, 19, 20, 28, 11, 27, 16, 0, 14, 22, 25, 4, 17, 30, 9, 1, 7, 23,13, 31, 26, 2, 8, 18, 12, 29, 5, 21, 10, 3, 24 ] # final permutation IP^-1 __fp = [ 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25, 32, 0, 40, 8, 48, 16, 56, 24 ] # Type of crypting being done ENCRYPT = 0x00 DECRYPT = 0x01 # Initialisation def __init__(self, key, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL): # Sanity checking of arguments. if len(key) != 8: raise ValueError(&quot;Invalid DES key size. Key must be exactly 8 bytes long.&quot;) _baseDes.__init__(self, mode, IV, pad, padmode) self.key_size = 8 self.L = [] self.R = [] self.Kn = [ [0] * 48 ] * 16 # 16 48-bit keys (K1 - K16) self.final = [] self.setKey(key) def setKey(self, key): &quot;&quot;&quot;Will set the crypting key for this object. Must be 8 bytes.&quot;&quot;&quot; _baseDes.setKey(self, key) self.__create_sub_keys() def __String_to_BitList(self, data): &quot;&quot;&quot;Turn the string data, into a list of bits (1, 0)&apos;s&quot;&quot;&quot; if _pythonMajorVersion &lt; 3: # Turn the strings into integers. Python 3 uses a bytes # class, which already has this behaviour. data = [ord(c) for c in data] l = len(data) * 8 result = [0] * l pos = 0 for ch in data: i = 7 while i &gt;= 0: if ch &amp; (1 &lt;&lt; i) != 0: result[pos] = 1 else: result[pos] = 0 pos += 1 i -= 1 return result def __BitList_to_String(self, data): &quot;&quot;&quot;Turn the list of bits -&gt; data, into a string&quot;&quot;&quot; result = [] pos = 0 c = 0 while pos &lt; len(data): c += data[pos] &lt;&lt; (7 - (pos % 8)) if (pos % 8) == 7: result.append(c) c = 0 pos += 1 if _pythonMajorVersion &lt; 3: return &apos;&apos;.join([ chr(c) for c in result ]) else: return bytes(result) def __permutate(self, table, block): &quot;&quot;&quot;Permutate this block with the specified table&quot;&quot;&quot; return list(map(lambda x: block[x], table)) # Transform the secret key, so that it is ready for data processing # Create the 16 subkeys, K[1] - K[16] def __create_sub_keys(self): &quot;&quot;&quot;Create the 16 subkeys K[1] to K[16] from the given key&quot;&quot;&quot; key = self.__permutate(des.__pc1, self.__String_to_BitList(self.getKey())) i = 0 # Split into Left and Right sections self.L = key[:28] self.R = key[28:] while i &lt; 16: j = 0 # Perform circular left shifts while j &lt; des.__left_rotations[i]: self.L.append(self.L[0]) del self.L[0] self.R.append(self.R[0]) del self.R[0] j += 1 # Create one of the 16 subkeys through pc2 permutation self.Kn[i] = self.__permutate(des.__pc2, self.L + self.R) i += 1 # Main part of the encryption algorithm, the number cruncher :) def __des_crypt(self, block, crypt_type): &quot;&quot;&quot;Crypt the block of data through DES bit-manipulation&quot;&quot;&quot; block = self.__permutate(des.__ip, block) self.L = block[:32] self.R = block[32:] # Encryption starts from Kn[1] through to Kn[16] if crypt_type == des.ENCRYPT: iteration = 0 iteration_adjustment = 1 # Decryption starts from Kn[16] down to Kn[1] else: iteration = 15 iteration_adjustment = -1 i = 0 while i &lt; 16: # Make a copy of R[i-1], this will later become L[i] tempR = self.R[:] # Permutate R[i - 1] to start creating R[i] self.R = self.__permutate(des.__expansion_table, self.R) # Exclusive or R[i - 1] with K[i], create B[1] to B[8] whilst here self.R = list(map(lambda x, y: x ^ y, self.R, self.Kn[iteration])) B = [self.R[:6], self.R[6:12], self.R[12:18], self.R[18:24], self.R[24:30], self.R[30:36], self.R[36:42], self.R[42:]] # Optimization: Replaced below commented code with above #j = 0 #B = [] #while j &lt; len(self.R): # self.R[j] = self.R[j] ^ self.Kn[iteration][j] # j += 1 # if j % 6 == 0: # B.append(self.R[j-6:j]) # Permutate B[1] to B[8] using the S-Boxes j = 0 Bn = [0] * 32 pos = 0 while j &lt; 8: # Work out the offsets m = (B[j][0] &lt;&lt; 1) + B[j][5] n = (B[j][1] &lt;&lt; 3) + (B[j][2] &lt;&lt; 2) + (B[j][3] &lt;&lt; 1) + B[j][4] # Find the permutation value v = des.__sbox[j][(m &lt;&lt; 4) + n] # Turn value into bits, add it to result: Bn Bn[pos] = (v &amp; 8) &gt;&gt; 3 Bn[pos + 1] = (v &amp; 4) &gt;&gt; 2 Bn[pos + 2] = (v &amp; 2) &gt;&gt; 1 Bn[pos + 3] = v &amp; 1 pos += 4 j += 1 # Permutate the concatination of B[1] to B[8] (Bn) self.R = self.__permutate(des.__p, Bn) # Xor with L[i - 1] self.R = list(map(lambda x, y: x ^ y, self.R, self.L)) # Optimization: This now replaces the below commented code #j = 0 #while j &lt; len(self.R): # self.R[j] = self.R[j] ^ self.L[j] # j += 1 # L[i] becomes R[i - 1] self.L = tempR i += 1 iteration += iteration_adjustment # Final permutation of R[16]L[16] self.final = self.__permutate(des.__fp, self.R + self.L) return self.final # Data to be encrypted/decrypted def crypt(self, data, crypt_type): &quot;&quot;&quot;Crypt the data in blocks, running it through des_crypt()&quot;&quot;&quot; # Error check the data if not data: return &apos;&apos; if len(data) % self.block_size != 0: if crypt_type == des.DECRYPT: # Decryption must work on 8 byte blocks raise ValueError(&quot;Invalid data length, data must be a multiple of &quot; + str(self.block_size) + &quot; bytes\\n.&quot;) if not self.getPadding(): raise ValueError(&quot;Invalid data length, data must be a multiple of &quot; + str(self.block_size) + &quot; bytes\\n. Try setting the optional padding character&quot;) else: data += (self.block_size - (len(data) % self.block_size)) * self.getPadding() # print &quot;Len of data: %f&quot; % (len(data) / self.block_size) if self.getMode() == CBC: if self.getIV(): iv = self.__String_to_BitList(self.getIV()) else: raise ValueError(&quot;For CBC mode, you must supply the Initial Value (IV) for ciphering&quot;) # Split the data into blocks, crypting each one seperately i = 0 dict = {} result = [] #cached = 0 #lines = 0 while i &lt; len(data): # Test code for caching encryption results #lines += 1 #if dict.has_key(data[i:i+8]): #print &quot;Cached result for: %s&quot; % data[i:i+8] # cached += 1 # result.append(dict[data[i:i+8]]) # i += 8 # continue block = self.__String_to_BitList(data[i:i+8]) # Xor with IV if using CBC mode if self.getMode() == CBC: if crypt_type == des.ENCRYPT: block = list(map(lambda x, y: x ^ y, block, iv)) #j = 0 #while j &lt; len(block): # block[j] = block[j] ^ iv[j] # j += 1 processed_block = self.__des_crypt(block, crypt_type) if crypt_type == des.DECRYPT: processed_block = list(map(lambda x, y: x ^ y, processed_block, iv)) #j = 0 #while j &lt; len(processed_block): # processed_block[j] = processed_block[j] ^ iv[j] # j += 1 iv = block else: iv = processed_block else: processed_block = self.__des_crypt(block, crypt_type) # Add the resulting crypted block to our list #d = self.__BitList_to_String(processed_block) #result.append(d) result.append(self.__BitList_to_String(processed_block)) #dict[data[i:i+8]] = d i += 8 # print &quot;Lines: %d, cached: %d&quot; % (lines, cached) # Return the full crypted string if _pythonMajorVersion &lt; 3: return &apos;&apos;.join(result) else: return bytes.fromhex(&apos;&apos;).join(result) def encrypt(self, data, pad=None, padmode=None): &quot;&quot;&quot;encrypt(data, [pad], [padmode]) -&gt; bytes data : Bytes to be encrypted pad : Optional argument for encryption padding. Must only be one byte padmode : Optional argument for overriding the padding mode. The data must be a multiple of 8 bytes and will be encrypted with the already specified key. Data does not have to be a multiple of 8 bytes if the padding character is supplied, or the padmode is set to PAD_PKCS5, as bytes will then added to ensure the be padded data is a multiple of 8 bytes. &quot;&quot;&quot; data = self._guardAgainstUnicode(data) if pad is not None: pad = self._guardAgainstUnicode(pad) data = self._padData(data, pad, padmode) return self.crypt(data, des.ENCRYPT) def decrypt(self, data, pad=None, padmode=None): &quot;&quot;&quot;decrypt(data, [pad], [padmode]) -&gt; bytes data : Bytes to be encrypted pad : Optional argument for decryption padding. Must only be one byte padmode : Optional argument for overriding the padding mode. The data must be a multiple of 8 bytes and will be decrypted with the already specified key. In PAD_NORMAL mode, if the optional padding character is supplied, then the un-encrypted data will have the padding characters removed from the end of the bytes. This pad removal only occurs on the last 8 bytes of the data (last data block). In PAD_PKCS5 mode, the special padding end markers will be removed from the data after decrypting. &quot;&quot;&quot; data = self._guardAgainstUnicode(data) if pad is not None: pad = self._guardAgainstUnicode(pad) data = self.crypt(data, des.DECRYPT) return self._unpadData(data, pad, padmode) ############################################################################# Triple DES############################################################################# class triple_des(_baseDes): “””Triple DES encryption/decrytpion class This algorithm uses the DES-EDE3 (when a 24 byte key is supplied) or the DES-EDE2 (when a 16 byte key is supplied) encryption methods. Supports ECB (Electronic Code Book) and CBC (Cypher Block Chaining) modes. pyDes.des(key, [mode], [IV]) key -&gt; Bytes containing the encryption key, must be either 16 or bytes long mode -&gt; Optional argument for encryption type, can be either pyDes.ECB (Electronic Code Book), pyDes.CBC (Cypher Block Chaining) IV -&gt; Optional Initial Value bytes, must be supplied if using CBC mode. Must be 8 bytes in length. pad -&gt; Optional argument, set the pad character (PAD_NORMAL) to use during all encrypt/decrpt operations done with this instance. padmode -&gt; Optional argument, set the padding mode (PAD_NORMAL or PAD_PKCS5) to use during all encrypt/decrpt operations done with this instance. &quot;&quot;&quot; def __init__(self, key, mode=ECB, IV=None, pad=None, padmode=PAD_NORMAL): _baseDes.__init__(self, mode, IV, pad, padmode) self.setKey(key) def setKey(self, key): &quot;&quot;&quot;Will set the crypting key for this object. Either 16 or 24 bytes long.&quot;&quot;&quot; self.key_size = 24 # Use DES-EDE3 mode if len(key) != self.key_size: if len(key) == 16: # Use DES-EDE2 mode self.key_size = 16 else: raise ValueError(&quot;Invalid triple DES key size. Key must be either 16 or 24 bytes long&quot;) if self.getMode() == CBC: if not self.getIV(): # Use the first 8 bytes of the key self._iv = key[:self.block_size] if len(self.getIV()) != self.block_size: raise ValueError(&quot;Invalid IV, must be 8 bytes in length&quot;) self.__key1 = des(key[:8], self._mode, self._iv, self._padding, self._padmode) self.__key2 = des(key[8:16], self._mode, self._iv, self._padding, self._padmode) if self.key_size == 16: self.__key3 = self.__key1 else: self.__key3 = des(key[16:], self._mode, self._iv, self._padding, self._padmode) _baseDes.setKey(self, key) # Override setter methods to work on all 3 keys. def setMode(self, mode): &quot;&quot;&quot;Sets the type of crypting mode, pyDes.ECB or pyDes.CBC&quot;&quot;&quot; _baseDes.setMode(self, mode) for key in (self.__key1, self.__key2, self.__key3): key.setMode(mode) def setPadding(self, pad): &quot;&quot;&quot;setPadding() -&gt; bytes of length 1. Padding character.&quot;&quot;&quot; _baseDes.setPadding(self, pad) for key in (self.__key1, self.__key2, self.__key3): key.setPadding(pad) def setPadMode(self, mode): &quot;&quot;&quot;Sets the type of padding mode, pyDes.PAD_NORMAL or pyDes.PAD_PKCS5&quot;&quot;&quot; _baseDes.setPadMode(self, mode) for key in (self.__key1, self.__key2, self.__key3): key.setPadMode(mode) def setIV(self, IV): &quot;&quot;&quot;Will set the Initial Value, used in conjunction with CBC mode&quot;&quot;&quot; _baseDes.setIV(self, IV) for key in (self.__key1, self.__key2, self.__key3): key.setIV(IV) def encrypt(self, data, pad=None, padmode=None): &quot;&quot;&quot;encrypt(data, [pad], [padmode]) -&gt; bytes data : bytes to be encrypted pad : Optional argument for encryption padding. Must only be one byte padmode : Optional argument for overriding the padding mode. The data must be a multiple of 8 bytes and will be encrypted with the already specified key. Data does not have to be a multiple of 8 bytes if the padding character is supplied, or the padmode is set to PAD_PKCS5, as bytes will then added to ensure the be padded data is a multiple of 8 bytes. &quot;&quot;&quot; ENCRYPT = des.ENCRYPT DECRYPT = des.DECRYPT data = self._guardAgainstUnicode(data) if pad is not None: pad = self._guardAgainstUnicode(pad) # Pad the data accordingly. data = self._padData(data, pad, padmode) if self.getMode() == CBC: self.__key1.setIV(self.getIV()) self.__key2.setIV(self.getIV()) self.__key3.setIV(self.getIV()) i = 0 result = [] while i &lt; len(data): block = self.__key1.crypt(data[i:i+8], ENCRYPT) block = self.__key2.crypt(block, DECRYPT) block = self.__key3.crypt(block, ENCRYPT) self.__key1.setIV(block) self.__key2.setIV(block) self.__key3.setIV(block) result.append(block) i += 8 if _pythonMajorVersion &lt; 3: return &apos;&apos;.join(result) else: return bytes.fromhex(&apos;&apos;).join(result) else: data = self.__key1.crypt(data, ENCRYPT) data = self.__key2.crypt(data, DECRYPT) return self.__key3.crypt(data, ENCRYPT) def decrypt(self, data, pad=None, padmode=None): &quot;&quot;&quot;decrypt(data, [pad], [padmode]) -&gt; bytes data : bytes to be encrypted pad : Optional argument for decryption padding. Must only be one byte padmode : Optional argument for overriding the padding mode. The data must be a multiple of 8 bytes and will be decrypted with the already specified key. In PAD_NORMAL mode, if the optional padding character is supplied, then the un-encrypted data will have the padding characters removed from the end of the bytes. This pad removal only occurs on the last 8 bytes of the data (last data block). In PAD_PKCS5 mode, the special padding end markers will be removed from the data after decrypting, no pad character is required for PAD_PKCS5. &quot;&quot;&quot; ENCRYPT = des.ENCRYPT DECRYPT = des.DECRYPT data = self._guardAgainstUnicode(data) if pad is not None: pad = self._guardAgainstUnicode(pad) if self.getMode() == CBC: self.__key1.setIV(self.getIV()) self.__key2.setIV(self.getIV()) self.__key3.setIV(self.getIV()) i = 0 result = [] while i &lt; len(data): iv = data[i:i+8] block = self.__key3.crypt(iv, DECRYPT) block = self.__key2.crypt(block, ENCRYPT) block = self.__key1.crypt(block, DECRYPT) self.__key1.setIV(iv) self.__key2.setIV(iv) self.__key3.setIV(iv) result.append(block) i += 8 if _pythonMajorVersion &lt; 3: data = &apos;&apos;.join(result) else: data = bytes.fromhex(&apos;&apos;).join(result) else: data = self.__key3.crypt(data, DECRYPT) data = self.__key2.crypt(data, ENCRYPT) data = self.__key1.crypt(data, DECRYPT) return self._unpadData(data, pad, padmode)","categories":[],"tags":[],"keywords":[]},{"title":"python encode&decode","slug":"python_encode_decode","date":"2017-05-05T08:31:02.638Z","updated":"2017-05-05T08:31:02.824Z","comments":true,"path":"2017/05/05/python_encode_decode/","link":"","permalink":"http://yoursite.com/2017/05/05/python_encode_decode/","excerpt":"1.编码说明首先要搞清楚，字符串在Python内部的表示是unicode编码原则： 在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 decode的作用是将其他编码的字符串转换成unicode编码， 如str1.decode(&apos;gb2312&apos;)，表示将gb2312编码的字符串转换成unicode编码。 encode的作用是将unicode编码转换成其他编码的字符串， 如str2.encode(&apos;gb2312&apos;)，表示将unicode编码的字符串转换成gb2312编码。","text":"1.编码说明首先要搞清楚，字符串在Python内部的表示是unicode编码原则： 在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 decode的作用是将其他编码的字符串转换成unicode编码， 如str1.decode(&apos;gb2312&apos;)，表示将gb2312编码的字符串转换成unicode编码。 encode的作用是将unicode编码转换成其他编码的字符串， 如str2.encode(&apos;gb2312&apos;)，表示将unicode编码的字符串转换成gb2312编码。 例如： gb2312&gt;&gt;&gt;utf-8 str1(gb2312) mstr=str1.decode(&apos;gb2312&apos;) mstr(unicode) str2=mstr.encode(&apos;utf-8&apos;) str2(utf-8) 或者 str1(gb2312) str2=str1.decode(&apos;gb2312&apos;).encode(&apos;utf-8&apos;) str2(utf-8) 2.base64编码Base64是一种基于64个可打印字符来表示二进制数据的表示方法。 由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。 三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。编码后的数据比原始数据略长，为原来的4/3。 Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据（或不可打印的字符串）。包括MIME的email，email via MIME, 在XML中存储复杂数据. 在邮件中的用途： 在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 在URL中的用途： 标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“”和“-”,这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“”在正则表达式中都可能具有特殊含义。**","categories":[],"tags":[],"keywords":[]},{"title":"nginx fundamental config","slug":"nginx_fundamental_config","date":"2017-05-02T01:21:52.041Z","updated":"2017-05-02T01:21:23.170Z","comments":true,"path":"2017/05/02/nginx_fundamental_config/","link":"","permalink":"http://yoursite.com/2017/05/02/nginx_fundamental_config/","excerpt":"","text":"# for push server #最大共享内存 push_stream_shared_memory_size 100m; #频道id最大长度 push_stream_max_channel_id_length 200; #每个频道最大的消息数目 push_stream_max_messages_stored_per_channel 20; #缓存消息超时 push_stream_message_ttl 5m; #向订阅者发送ping(心跳包)的间隔时间 push_stream_ping_message_interval 10s; #订阅者的过期时间 push_stream_subscriber_connection_ttl 15m; #长连接的过期时间 push_stream_longpolling_connection_ttl 30s; #标识为广播通道 push_stream_broadcast_channel_prefix &quot;broad_&quot;; #推送消息的格式 push_stream_message_template &quot;{\\&quot;id\\&quot;:~id~,\\&quot;channel\\&quot;:\\&quot;~channel~\\&quot;,\\&quot;text\\&quot;:\\&quot;~text~\\&quot;}&quot;; #这个参数被设为on后, 则只有先在pub模块中POST一次数据, sub模块才可以监听指定频道, 否则会返回403错误. push_stream_authorized_channels_only off; #用户可以请求的广播频道的最大数量 push_stream_broadcast_channel_max_qtd 3; server { listen 8001; server_name localhost; #数据包是否马上传输，on为不马上传输，待数据包达到最大 tcp_nopush off; #数据包不延迟 tcp_nodelay on; #客户端的超时时间，指定了与client的keep-alive连接超时时间，服务器将会在这个时间后关闭连接。 keepalive_timeout 10; #nginx关闭连接的超时时间 send_timeout 10; #指定等待client发送一个请求体的读取超时时间 client_body_timeout 10; #指定等待client发送一个请求头的超时时间 client_header_timeout 10; #从硬盘写到socket时，提升性能（减少拷贝） sendfile on; #nginx默认会用client_header_buffer_size这个buffer来读取header值 client_header_buffer_size 1k; #如果header过大，它会使用large_client_header_buffers来读取 large_client_header_buffers 2 4k; #客户端最大请求体的大小（与上传文件大小相关） client_max_body_size 1k; #缓冲区代理缓冲用户端请求的最大字节数 client_body_buffer_size 1k; #忽略不合法的HTTP头部。如果将其设置为off，那么当出现不合法的HTTP头部时，Nginx会拒绝服务，并直接向用户发送400（Bad Request）错误。如果将其设置为on，则会忽略此HTTP头部。 ignore_invalid_headers on; location /channels-stats { push_stream_channels_statistics; set $push_stream_channel_id $arg_id; } location /pub { push_stream_publisher admin; set $push_stream_channel_id $arg_id; push_stream_store_messages off; push_stream_keepalive on; client_max_body_size 32k; client_body_buffer_size 32k; } location ~ /sub/(.*) { push_stream_subscriber; set $push_stream_channels_path $1; push_stream_header_template &quot;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot;&gt;\\r\\n&lt;meta http-equiv=\\&quot;Cache-Control\\&quot; content=\\&quot;no-store\\&quot;&gt;\\r\\n&lt;meta http-equiv=\\&quot;Cache-Control\\&quot; content=\\&quot;no-cache\\&quot;&gt;\\r\\n&lt;meta http-equiv=\\&quot;Pragma\\&quot; content=\\&quot;no-cache\\&quot;&gt;\\r\\n&lt;meta http-equiv=\\&quot;Expires\\&quot; content=\\&quot;Thu, 1 Jan 1970 00:00:00 GMT\\&quot;&gt;\\r\\n&lt;script type=\\&quot;text/javascript\\&quot;&gt;\\r\\nwindow.onError = null;\\r\\ntry{ document.domain = (window.location.hostname.match(/^(\\d{1,3}\\.){3}\\d{1,3}$/)) ? window.location.hostname : window.location.hostname.split(&apos;.&apos;).slice(-1 * Math.max(window.location.hostname.split(&apos;.&apos;).length - 1, (window.location.hostname.match(/(\\w{4,}\\.\\w{2}|\\.\\w{3,})$/) ? 2 : 3))).join(&apos;.&apos;);}catch(e){}\\r\\nparent.PushStream.register(this);\\r\\n&lt;/script&gt;\\r\\n&lt;/head&gt;\\r\\n&lt;body&gt;&quot;; push_stream_message_template &quot;&lt;script&gt;p(~id~,&apos;~channel~&apos;,&apos;~text~&apos;);&lt;/script&gt;&quot;; push_stream_footer_template &quot;&lt;/body&gt;&lt;/html&gt;&quot;; push_stream_content_type &quot;text/html; charset=utf-8&quot;; } location ~ /ev/(.*) { push_stream_subscriber; set $push_stream_channels_path $1; push_stream_eventsource_support on; } location ~ /lp/(.*) { push_stream_subscriber long-polling; set $push_stream_channels_path $1; } location ~ /ws/(.*) { push_stream_websocket; set $push_stream_channels_path $1; push_stream_store_messages on; push_stream_websocket_allow_publish on; } }","categories":[],"tags":[],"keywords":[]},{"title":"python concurrency","slug":"python_concurrency","date":"2017-05-01T07:39:15.064Z","updated":"2017-04-29T07:04:58.755Z","comments":true,"path":"2017/05/01/python_concurrency/","link":"","permalink":"http://yoursite.com/2017/05/01/python_concurrency/","excerpt":"1. python StacklessStackless Python几乎有匪夷所思的并发性能，比其他方案快上几十倍，而且借助Stackless Python提供的channel机制，实现也相当简单。 2. Python thread 线程 thread模块和threading提供基本相同的性能； threading模块只是对thread的一种封装； threading简单，但由于自身本身实例维护方面的开销，相对慢一点； 从代码实现体验来说，用threading配合Queue比直接用thread方便，并且出错的机会也要少很多； import threading def foo(a,b): return a,b send_thread=threading.thread(target=foo,args=(arg1,arg2)) send_thread.start() 3. Python processing 进程processing模块给出的进程方案大致比thread线程要慢一倍，并且这是在我特意调整虚拟机给它预备了足够空闲内存、避免使用交换分区的情况下取得的（特意分给虚拟机700多M内存就是为了这个）。而其他方案仅仅占用数M内存，完全无需特意调大可用内存总量。当然，如果给虚拟机多启用几个核心的话，processing也许会占上点便宜，毕竟目前thread模块是不能有效利用多cpu资源的（经实验，Stackless Python在开启双核的情况下表现的性能和单核是一样的，说明也是不能有效利用多cpu）。因此一种比较合理的做法是根据cpu的数量，启用少量几个进程，而在进程内部再开启线程进行实际业务处理，这也是目前Python社区推荐的有效利用多cpu资源的办法。好在processing配合其自身提供的Queue模块，编程体验还是比较轻松的。","text":"1. python StacklessStackless Python几乎有匪夷所思的并发性能，比其他方案快上几十倍，而且借助Stackless Python提供的channel机制，实现也相当简单。 2. Python thread 线程 thread模块和threading提供基本相同的性能； threading模块只是对thread的一种封装； threading简单，但由于自身本身实例维护方面的开销，相对慢一点； 从代码实现体验来说，用threading配合Queue比直接用thread方便，并且出错的机会也要少很多； import threading def foo(a,b): return a,b send_thread=threading.thread(target=foo,args=(arg1,arg2)) send_thread.start() 3. Python processing 进程processing模块给出的进程方案大致比thread线程要慢一倍，并且这是在我特意调整虚拟机给它预备了足够空闲内存、避免使用交换分区的情况下取得的（特意分给虚拟机700多M内存就是为了这个）。而其他方案仅仅占用数M内存，完全无需特意调大可用内存总量。当然，如果给虚拟机多启用几个核心的话，processing也许会占上点便宜，毕竟目前thread模块是不能有效利用多cpu资源的（经实验，Stackless Python在开启双核的情况下表现的性能和单核是一样的，说明也是不能有效利用多cpu）。因此一种比较合理的做法是根据cpu的数量，启用少量几个进程，而在进程内部再开启线程进行实际业务处理，这也是目前Python社区推荐的有效利用多cpu资源的办法。好在processing配合其自身提供的Queue模块，编程体验还是比较轻松的。 4. python greenlet 超轻量级方案基于greenlet的实现则性能仅次于Stackless Python，大致比Stackless Python慢一倍，比其他方案快接近一个数量级。其实greenlet不是一种真正的并发机制，而是在同一线程内，在不同函数的执行代码块之间切换，实施“你运行一会、我运行一会”，并且在进行切换时必须指定何时切换以及切换到哪。greenlet的接口是比较简单易用的，但是使用greenlet时的思考方式与其他并发方案存在一定区别。线程/进程模型在大逻辑上通常从并发角度开始考虑，把能够并行处理的并且值得并行处理的任务分离出来，在不同的线程/进程下运行，然后考虑分离过程可能造成哪些互斥、冲突问题，将互斥的资源加锁保护来保证并发处理的正确性。greenlet则是要求从避免阻塞的角度来进行开发，当出现阻塞时，就显式切换到另一段没有被阻塞的代码段执行，直到原先的阻塞状况消失以后，再人工切换回原来的代码段继续处理。因此，greenlet本质是一种合理安排了的串行，实验中greenlet方案能够得到比较好的性能表现，主要也是因为通过合理的代码执行流程切换，完全避免了死锁和阻塞等情况（执行带屏幕输出的ring_greenlet.py我们会看到脚本总是一个一个地处理消息，把一个消息在环上从头传到尾之后，再开始处理下一个消息）。因为greenlet本质是串行，因此在没有进行显式切换时，代码的其他部分是无法被执行到的，如果要避免代码长时间占用运算资源造成程序假死，那么还是要将greenlet与线程/进程机制结合使用（每个线程、进程下都可以建立多个greenlet，但是跨线程/进程时greenlet之间无法切换或通讯）。 Stackless则比较特别，对很多资源从底层进行了并发改造，并且提供了channel等更适合“并发”的通讯机制实现，使得资源互斥冲突的可能性大大减小，并发性能自然得以提高。粗糙来讲，greenlet是“阻塞了我就先干点儿别的，但是程序员得明确告诉greenlet能先干点儿啥以及什么时候回来”；Stackless则是“东西我已经改造好了，你只要用我的东西，并发冲突就不用操心，只管放心大胆地并发好了”。greenlet应该是学习了Stackless的上下文切换机制，但是对底层资源没有进行适合并发的改造。并且实际上greenlet也没有必要改造底层资源的并发性，因为它本质是串行的单线程，不与其他并发模型混合使用的话是无法造成对资源的并发访问的。 5. python greenlet 封装后eventlet方案greenlet 封装后的 eventlet 方案，eventlet 是基于 greenlet 实现的面向网络应用的并发处理框架，提供“线程”池、队列等与其他 Python 线程、进程模型非常相似的 api，并且提供了对 Python 发行版自带库及其他模块的超轻量并发适应性调整方法，比直接使用 greenlet 要方便得多。并且这个解决方案源自著名虚拟现实游戏“第二人生”，可以说是久经考验的新兴并发处理模型。其基本原理是调整 Python 的 socket 调用，当发生阻塞时则切换到其他 greenlet 执行，这样来保证资源的有效利用。需要注意的是： eventlet 提供的函数只能对 Python 代码中的 socket 调用进行处理，而不能对模块的 C 语言部分的 socket 调用进行修改。对后者这类模块，仍然需要把调用模块的代码封装在 Python 标准线程调用中，之后利用 eventlet 提供的适配器实现 eventlet 与标准线程之间的协作。 再有，虽然 eventlet 把 api 封装成了非常类似标准线程库的形式，但两者的实际并发执行流程仍然有明显区别。在没有出现 I/O 阻塞时，除非显式声明，否则当前正在执行的 eventlet 永远不会把 cpu 交给其他的 eventlet，而标准线程则是无论是否出现阻塞，总是由所有线程一起争夺运行资源。所有 eventlet 对 I/O 阻塞无关的大运算量耗时操作基本没有什么帮助。 在性能测试结果方面，eventlet 消耗的运行时间大致是 greenlet 方案的 3 到 5 倍，而 Python 标准线程模型的 thread 方式消耗的运行时间大致是 eventlet 测试代码的 8 到 10 倍。其中前者可能是因为我们在 eventlet 的测试代码中，使用队列机制来完成所有的消息传递，而队列上的访问互斥保护可能额外消耗了一些运算资源。总体而言，eventlet 模型的并发性能虽然比 Stackless Python 和直接使用 greenlet 有一定差距，但仍然比标准线程模型有大约一个数量级的优势，这也就不奇怪近期很多强调并发性能的网络服务器实现采取 eventlet 、线程、进程三者组合使用的实现方案。","categories":[],"tags":[],"keywords":[]},{"title":"PEP-8","slug":"PEP_8","date":"2017-04-28T07:36:16.209Z","updated":"2017-04-28T07:36:16.342Z","comments":true,"path":"2017/04/28/PEP_8/","link":"","permalink":"http://yoursite.com/2017/04/28/PEP_8/","excerpt":"","text":"1. 代码编排 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 2. 文档编排 模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。 不要在一句import中多个库，比如import os, sys不推荐。 如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。 3. 空格的使用总体原则，避免不必要的空格。 1 各种右括号前不要加空格。 2 逗号、冒号、分号前不要加空格。 3 函数的左括号前不要加空格。如Func(1)。 4 序列的左括号前不要加空格。如list[2]。 5 操作符左右各加一个空格，不要为了对齐增加空格。 6 函数默认参数使用的赋值符左右省略空格。 7 不要将多句语句写在同一行，尽管使用‘；’允许。 8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 4. 注释总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！ 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 1 块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如： # Description : Module config. # # Input : None # # Output : None 2 行注释，在一句代码后加注释。比如：x = x + 1 # Increment x 但是这种方式尽量少使用。 3 避免无谓的注释。 5. 文档描述1 为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。 2 如果docstring要换行，参考如下例子,详见PEP 257 &quot;&quot;&quot;Return a foobang Optional plotz says to frobnicate the bizbaz first. &quot;&quot;&quot; 6. 命名规范总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。 1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。 2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。 3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。 4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。 5 异常命名使用CapWords+Error后缀的方式。 6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是__all__机制;二是前缀一个下划线。 7 函数命名使用全部小写的方式，可以使用下划线。 8 常量命名使用全部大写的方式，可以使用下划线。 9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。 9 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。 11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。 12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。 13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。 7. 编码建议1 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。2 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。3 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。4 异常中不要使用裸露的except，except后跟具体的exceptions。5 异常中try的代码尽可能少。比如： try: value = collection[key] except KeyError: return key_not_found(key) else: return handle_value(value) 要优于 try: # Too broad! return handle_value(collection[key]) except KeyError: # Will also catch KeyError raised by handle_value() return key_not_found(key) 6 使用startswith() and endswith()代替切片进行序列前缀或后缀的检查。比如： Yes: if foo.startswith(&apos;bar&apos;):优于 No: if foo[:3] == &apos;bar&apos;: 7 使用isinstance()比较对象的类型。比如 Yes: if isinstance(obj, int): 优于 No: if type(obj) is type(1): 8 判断序列空或不空，有如下规则 Yes: if not seq: if seq: 优于 No: if len(seq) if not len(seq) 9 字符串不要以空格收尾。10 二进制数据判断使用 if boolvalue的方式。","categories":[],"tags":[],"keywords":[]},{"title":"if-else/if","slug":"if_else","date":"2017-04-14T02:08:51.742Z","updated":"2017-04-14T13:04:47.982Z","comments":true,"path":"2017/04/14/if_else/","link":"","permalink":"http://yoursite.com/2017/04/14/if_else/","excerpt":"","text":"最近在OJ上刷题，总是会“莫名其妙”的出现许多错误，截止今天再次莫名出错，着实不能再忍受，仔细翻阅与之前犯错的对比发现，对于if-else/if理解的竟然有偏差，直接上代码 for i in range(10): if i&lt;5: print &quot;A&quot;, print &quot;B&quot;, A B A B A B A B A B B B B B Bfor i in range(10): if i&lt;5: print &quot;A&quot;, else: print &quot;B&quot;, A A A A A B B B B B重新翻阅基础知识，if/else 单词执行只执行其中一步，同try/except而if+，之后的语句则是不管if执行与否，其后程序必执行很遗憾，这么简单的问题啊，竟然稀里糊涂的用了这么久（基础啊基础！）","categories":[],"tags":[],"keywords":[]},{"title":"echarts collocation china_map (geo)","slug":"echarts_chinamap","date":"2017-04-12T07:54:38.989Z","updated":"2017-04-12T08:02:32.250Z","comments":true,"path":"2017/04/12/echarts_chinamap/","link":"","permalink":"http://yoursite.com/2017/04/12/echarts_chinamap/","excerpt":"","text":"1.图表基本配置// 初始化echarts示例mapChart var mapChart = echarts.init(document.getElementById(&apos;mapcontainer&apos;)); // mapChart的配置 var option = { }; 2.新建一个地理坐标系 geo ，地图类型为中国地图var option = { geo: { map: &apos;china&apos; } geo.map 属性定义该地理坐标系中的地图数据，这里我们要用 china.js ，设置map值为 ‘china’ 。这里需要注意，中国地图的map值为 ‘china’ ，世界地图的map值为 ‘world’ ，但如果要引用省市自治区地图ap 值为简体中文，例如 beijing.js ，map 值为 ’北京’ 。 3.调用 setOption(option) 为图表设置配置项mapChart.setOption(option); 4.基本的地图设置var option = { geo: { map: &apos;china&apos;, itemStyle: { // 定义样式 normal: { // 普通状态下的样式 areaColor: &apos;#323c48&apos;, borderColor: &apos;#111&apos; }, emphasis: { // 高亮状态下的样式 areaColor: &apos;#2a333d&apos; } } }, backgroundColor: &apos;#404a59&apos;, // 图表背景色 } 5.绘制散点图(加载数据) 新建散点图 series 在 option 中添加一个 series ， series 的类型为散点图 scatter ，坐标系为地理坐标系 geo var option = { geo: { ... }, backgroundColor: &apos;#404a59&apos;, series: [ { name: &apos;销量&apos;, // series名称 type: &apos;scatter&apos;, // series图表类型 coordinateSystem: &apos;geo&apos; // series坐标系类型 } ] } 添加数据 ECharts 中 series.data 是定义图表数据内容的数组，其中每个项数据格式为（标准格式） { name: &apos;北京&apos;, // 数据项名称，在这里指地区名称 value: [ // 数据项值 116.46, // 地理坐标，经度 39.92, // 地理坐标，纬度 340 // 北京的数值，可添加 ] } 添加数据（自处理依据需求） 首先我们将需要渲染的数据转换成上述数据格式，存在一个变量中 var myData = [ {name: &apos;北京&apos;, value: [121.15, 31.89, value1，value2]}, {name: &apos;天津&apos;, value: [109.781327, 39.608266, value1，value2]}, {name: &apos;广州&apos;, value: [120.38, 37.35, value1，value2]}, {name: &apos;西安&apos;, value: [122.207216, 29.985295, value1，value2]}, ... ] 然后，将 myData 赋值给 series.data var option = { geo: { ... }, backgroundColor: &apos;#404a59&apos;, series: [ { name: &apos;销量&apos;, type: &apos;scatter&apos;, coordinateSystem: &apos;geo&apos;, data: myData // series数据内容 } ] } 添加视觉映射组件 视觉映射组件 是标识某一数据范围内数据及颜色对应关系的控件，视觉映射组件分为连续型和分段型，这里我们选用连续型 type:continuous 。同时，通过视觉映射组件可以实现 ECharts 值域漫游功能，即通过拖拽控件手柄选择不同数值范围，达到对图表数据的筛选显示。 在 visualMap 属性中设置值域控件的相关配置 var option = { ... visualMap: { type: &apos;continuous&apos;, // 连续型 min: 0, // 值域最小值，必须参数 max: 200, // 值域最大值，必须参数 calculable: true, // 是否启用值域漫游 inRange: { color: [&apos;#50a3ba&apos;,&apos;#eac736&apos;,&apos;#d94e5d&apos;] // 指定数值从低到高时的颜色变化 }, textStyle: { color: &apos;#fff&apos; // 值域控件的文本颜色 } } } 6.结果图http://echarts.baidu.com/demo.html#scatter-map","categories":[],"tags":[],"keywords":[]},{"title":"Deadlock","slug":"deadlock","date":"2017-04-12T07:09:03.924Z","updated":"2017-04-12T07:03:52.096Z","comments":true,"path":"2017/04/12/deadlock/","link":"","permalink":"http://yoursite.com/2017/04/12/deadlock/","excerpt":"","text":"1.死锁的定义如果一个进程集合中的每个进程都在等待只能由该进程集合中其他进程才能引发的事件，那么该进程集合就是死锁的。 2.死锁产生的原因 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当等。 3.死锁产生的必要条件 互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待条件：已经得到了某个资源的进程可以再请求新的资源。 不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，只能被占有它的进程显式地释放； 环路等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 4.处理死锁的四种策略 鸵鸟策略（忽略死锁） 检测死锁并恢复 仔细对资源进行分配，动态地避免死锁 通过破坏引起死锁的四个必要条件之一，防止死锁的产生 5.避免死锁的主要算法银行家算法 避免死锁的主要算法是基于一个安全状态的概念。在任何时刻，如果没有死锁发生，并且即使所有进程忽然请求对资源的最大请求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。银行家算法从判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求，如果满足请求后系统仍然是安全的，就予以分配。不安全状态不一定引起死锁，因为客户不一定需要其最大贷款额度。*","categories":[],"tags":[],"keywords":[]},{"title":"single instance","slug":"single_instance","date":"2017-04-12T06:41:13.665Z","updated":"2017-04-12T07:08:57.415Z","comments":true,"path":"2017/04/12/single_instance/","link":"","permalink":"http://yoursite.com/2017/04/12/single_instance/","excerpt":"单例模式（四种方法）方法1 实现new方法 并在将一个类的实例绑定到类变量_instance上, 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a one和two完全相同,可以用id(), ==, is检测 print id(one) 29097904 print id(two) 29097904 print one == two True print one is two True","text":"单例模式（四种方法）方法1 实现new方法 并在将一个类的实例绑定到类变量_instance上, 如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回 如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 one = MyClass() two = MyClass() two.a = 3 print one.a one和two完全相同,可以用id(), ==, is检测 print id(one) 29097904 print id(two) 29097904 print one == two True print one is two True 方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法) 同一个类的所有实例天然拥有相同的行为(方法), 只需要保证同一个类的所有实例具有相同的状态(属性)即可 所有实例共享属性的最简单最直接的方法就是dict属性指向(引用)同一个字典(dict) class Borg(object): _state = {} def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return ob class MyClass2(Borg): a = 1 one = MyClass2() two = MyClass2() two.a = 3 print one.a 3 print id(one) 28873680 print id(two) 28873712 print one == two False print one is two False 但是one和two具有相同的（同一个dict属性）,见: print id(one.__dict__) 30104000 print id(two.__dict__) 30104000 方法3:本质上是方法1的升级（或者说高级）版 使用metaclass（元类）的高级python用法 class Singleton2(type): def __init__(cls, name, bases, dict): super(Singleton2, cls).__init__(name, bases, dict) cls._instance = None def __call__(cls, *args, **kw): if cls._instance is None: cls._instance = super(Singleton2, cls).__call__(*args, **kw) return cls._instance class MyClass3(object): __metaclass__ = Singleton2 one = MyClass3() two = MyClass3() two.a = 3 print one.a 3 print id(one) 31495472 id(two) 31495472 print one == two True print one is two True 方法4:也是方法1的升级（高级）版本 使用装饰器(decorator), 这是一种更pythonic,更elegant的方法, 单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的 def singleton(cls, *args, **kw): instances = {} def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return _singleton @singleton class MyClass4(object): a = 1 def __init__(self, x=0): self.x = x one = MyClass4() two = MyClass4() two.a = 3 print one.a 3 print id(one) 29660784 print id(two) 29660784 print one == two True print one is two True one.x = 1 print one.x 1 print two.x 1","categories":[],"tags":[],"keywords":[]},{"title":"mime.type","slug":"mime_type","date":"2017-04-10T06:04:14.888Z","updated":"2017-04-10T06:04:14.996Z","comments":true,"path":"2017/04/10/mime_type/","link":"","permalink":"http://yoursite.com/2017/04/10/mime_type/","excerpt":"","text":"常见的MIME类型 超文本标记语言文本 .htm,.html text/html 普通文本.txt text/plain RTF文本 .rtf application/rtf GIF图形 .gif image/gif JPEG图形 .ipeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 .mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar","categories":[],"tags":[],"keywords":[]},{"title":"HEXO collocation","slug":"hexo_collocation","date":"2017-04-06T02:30:00.824Z","updated":"2017-04-12T06:45:25.978Z","comments":true,"path":"2017/04/06/hexo_collocation/","link":"","permalink":"http://yoursite.com/2017/04/06/hexo_collocation/","excerpt":"部署步骤一、配置环境1.安装node.js2.安装git3.申请github4.安装hexo$ sudo npm install –g hexo 5.初始化$ hexo init 6.生成静态页面$ hexo generate 7.本地启动$ hexo server –p 3000 （端口号本地自定）","text":"部署步骤一、配置环境1.安装node.js2.安装git3.申请github4.安装hexo$ sudo npm install –g hexo 5.初始化$ hexo init 6.生成静态页面$ hexo generate 7.本地启动$ hexo server –p 3000 （端口号本地自定） 二、配置gihub1.建立仓库（repository） 创建仓库名 your_name.github.io 关联github $ vim _config.yml deploy: type:git (github) repository: http://github.com/arronrose/Arronrose.github.io.git branch: master 部署git在线上 npm install hexo-deployer-git –save 配置hexo hexo deploy 2.部署步骤 hexo clean hexo generate hexo deploy 添加文章$ hexo new “my new post” 得到G:\\blog\\source_posts\\my-new-post.md 修改my-new-post.md（markdown 文件，同HTML，比html精简） $ hexo g 等价于 generate $ hexo d 等价于 deploy","categories":[],"tags":[],"keywords":[]},{"title":"callback_function","slug":"callback_function","date":"2017-04-06T02:19:56.403Z","updated":"2017-04-10T02:42:23.226Z","comments":true,"path":"2017/04/06/callback_function/","link":"","permalink":"http://yoursite.com/2017/04/06/callback_function/","excerpt":"什么是回调函数？我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。","text":"什么是回调函数？我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。如下图所示（图片来源：维基百科）： 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例： even.py 回调函数1生成一个2k形式的偶数 def double(x): return x * 2 回调函数2生成一个4k形式的偶数 def quadruple(x): return x * 4 callback_demo.py from even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数 def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数(主函数)def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if __name__ == &quot;__main__&quot;: main() 运行callback_demp.py，输出如下： 3 5 9 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"crontab","slug":"crontab_time","date":"2017-04-05T13:35:42.719Z","updated":"2017-04-05T13:35:42.809Z","comments":true,"path":"2017/04/05/crontab_time/","link":"","permalink":"http://yoursite.com/2017/04/05/crontab_time/","excerpt":"一. crontab定时器服务配置1、定义： crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。","text":"一. crontab定时器服务配置1、定义： crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。 2、安装（默认自带crontab） 假如执行crontab报下面的错误即需要安装一下。 bash: crontab: command not found 确认crontab是否安装： 执行 crontab 命令如果报 command not found，就表明没有安装 安装 crontab 执行 yum install -y vixie-cron 确认是否安装成功: 执行 crontab -l 看是否设置了开机自动启动 chkconfig –list crond 启动crontab service crond start 二. 为当前用户创建定时服务 键入 crontab -e 编辑crontab服务文件 例如 文件内容如下： /2 * /bin/sh /home/admin/jiaoben/buy/deleteFile.sh 保存文件并并退出 /2 * /bin/sh /home/admin/jiaoben/buy/deleteFile.sh /2 * 通过这段字段可以设定什么时候执行脚本 /bin/sh /home/admin/jiaoben/buy/deleteFile.sh 这一字段可以设定你要执行的脚本，这里要注意一下bin/sh 是指运行 脚本的命令 后面一段时指脚本存放的路径 查看该用户下的crontab服务是否创建成功， 用 crontab -l 命令 启动crontab服务 一般启动服务用 /sbin/service crond start 若是根用户的cron服务可以用 sudo service crond start， 这里还是要注意 下 不同版本Linux系统启动的服务的命令也不同 ，像我的虚拟机里只需用 sudo service cron restart 即可，若是在根用下直接键入service cron start就能启动服务 查看服务是否已经运行用 ps -ax | grep cron crontab命令 crontab -u //设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数 crontab -l //列出某个用户cron服务的详细内容 rontab -r //删除没个用户的cron服务 crontab -e //编辑某个用户的cron服务 crontab命令选项: -u指定一个用户 -l列出某个用户的任务计划 -r删除某个用户的任务 -e编辑某个用户的任务 cron文件语法: 分 小时 日 月 星期 命令 0-59 0-23 1-31 1-12 0-6 command (取值范围,0表示周日一般一行对应一个任务) 记住几个特殊符号的含义: “*”代表取值范围内的数字, “/”代表”每”, “-”代表从某个数字到某个数字, “,”分开几个离散的数字 新增调度任务 新增调度任务可用两种方法： 1)、在命令行输入: crontab -e 然后添加相应的任务，wq存盘退出。 2)、直接编辑/etc/crontab 文件，即vi /etc/crontab，添加相应的任务。 查看调度任务 crontab -l //列出当前的所有调度任务 crontab -l -u jp //列出用户jp的所有调度任务 删除任务调度工作 crontab -r //删除所有任务调度工作","categories":[],"tags":[],"keywords":[]},{"title":"mysql deploy","slug":"mysql_deploy","date":"2017-04-05T12:25:15.353Z","updated":"2017-04-05T12:49:23.114Z","comments":true,"path":"2017/04/05/mysql_deploy/","link":"","permalink":"http://yoursite.com/2017/04/05/mysql_deploy/","excerpt":"","text":"MySQL数据库如何实现远程登录1.修改配置文件/etc/mysql找到my.cnf，不清楚mysql配置文件编码的话，建议使用vi /etc/mysql/my.cnfi到bind-address 127.0.0.1注释掉这句话：# bind-address 127.0.0.1：wq保存并退出，如果出现问题，则使用：w !sudo tee % 2.修改mysql hostmysql&gt; use mysqlmysql&gt; update user set Host=’%’ where User=’root’mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘myuser’@’%’ IDENTIFIED BY ‘mypwd’ WITH GRANT OPTIONmysql&gt; FLUSH PRIVILEGES 3.重启mysql/etc/init.d/mysql stop/etc/init.d/mysql start","categories":[],"tags":[],"keywords":[]},{"title":"git conclusion","slug":"git_conclusion","date":"2017-04-05T08:49:59.000Z","updated":"2017-04-05T08:54:20.337Z","comments":true,"path":"2017/04/05/git_conclusion/","link":"","permalink":"http://yoursite.com/2017/04/05/git_conclusion/","excerpt":"","text":"git是三个文件（本地–本地隐藏文件.git–远程仓库）先pull再add然后commit最后push 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com” cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com” (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag (打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中)","categories":[],"tags":[],"keywords":[]},{"title":"asynchronous","slug":"asynchronous","date":"2016-11-10T03:16:55.000Z","updated":"2017-04-05T08:32:05.357Z","comments":true,"path":"2016/11/10/asynchronous/","link":"","permalink":"http://yoursite.com/2016/11/10/asynchronous/","excerpt":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);","text":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);什么是回调函数？ 我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。 打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势 从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例： even.py回调函数1生成一个2k形式的偶数def double(x): return x * 2 回调函数2生成一个4k形式的偶数def quadruple(x): return x * 4 callback_demo.pyfrom even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数，这里是程序的主函数def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if name == “main“: main() 运行callback_demp.py，输出如下：359 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"To 365","slug":"To 365","date":"2016-11-06T14:57:12.000Z","updated":"2016-11-06T15:16:31.427Z","comments":true,"path":"2016/11/06/To 365/","link":"","permalink":"http://yoursite.com/2016/11/06/To 365/","excerpt":"","text":"都深夜了，这23岁的生日过的也不是那么的顺畅，我也能感受到这叹息的威力，划破黑衣的霾，直击人心得脉。想成事，必先受其苦，这是亘古不变的，经历了这么多事，风霜阴雨的，哪能忘却了？只是，日复一日的生活，水滴石穿着我们的爱心， 耐心和信心。唯有不忘初心，方能见前后，知因果。我写着写着自己都不知道要说啥，不妨罗列出来，锱铢一二： 干什么事都得定好目标，有了目标人才会有动力，即时面临艰难险阻，咬牙抬头的那一刻，看到梦想的目标，定然也会蓄力拼搏，殊死搏斗，不向命运低头； 出了较长远的大目标外（梦想如是。。。），也要定阶段性的小目标，一方面，小的目标可以较为容易的实现，可以激励自己，让自己获得长久“战斗”下去的勇气，另一方面，也告诫自己，困难还很多，千万别“轻敌”； 情感要有，纪律也不能丢掉。无规矩，不方圆，这种到底无需赘述。是非分明，奖惩分明，要的不是铁面无私，要的是活的明白！浑浑噩噩的，一天天过去了，一件件事经历了，然而并不能为以后树立良好的经验榜样，只有明明白白的活着，才能感受到生命的意义。除此以外，规矩的建立也是为了防止自己逾越雷池，犯下大错，因此，是亟待建立并付诸于心动的； 互相提高才是正道，共同进步才是正确。且说不到近朱者赤近墨者黑（没有那么严重），就用榜样来讲吧，良好的榜样，才能促进共同的进步，如果不思进取，最终的结果也定然不会太美丽。爱情终究会成为亲情，成为弥漫在你周围的空气一般，平淡，在平淡。长远的认识，或许会帮助自己更加轻松的理解生活的真谛。加油！","categories":[],"tags":[],"keywords":[]},{"title":"Nginx","slug":"Nginx","date":"2016-11-05T06:39:17.000Z","updated":"2016-11-05T06:57:41.397Z","comments":true,"path":"2016/11/05/Nginx/","link":"","permalink":"http://yoursite.com/2016/11/05/Nginx/","excerpt":"","text":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-11-05T06:07:27.123Z","updated":"2016-11-05T06:30:07.689Z","comments":true,"path":"2016/11/05/hello-world/","link":"","permalink":"http://yoursite.com/2016/11/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}