{"meta":{"title":"Science & Technology For Future","subtitle":"Sciencec and Technology","description":null,"author":"Arron Rose","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mysql deploy","slug":"mysql_deploy","date":"2017-04-05T12:25:15.353Z","updated":"2017-04-05T12:42:29.397Z","comments":true,"path":"2017/04/05/mysql_deploy/","link":"","permalink":"http://yoursite.com/2017/04/05/mysql_deploy/","excerpt":"","text":"MySQL数据库如何实现远程登录**1.修改配置文件 /etc/mysql 找到my.cnf，不清楚mysql配置文件编码的话，建议使用 vi /etc/mysql/my.cnf i到bind-address 127.0.0.1 注释掉这句话：# bind-address 127.0.0.1 ：wq保存并退出，如果出现问题，则使用 ：w !sudo tee % **2.修改mysql host mysql&gt; use mysql mysql&gt; update user set Host=’%’ where User=’root’ mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘myuser’@’%’ IDENTIFIED BY ‘mypwd’ WITH GRANT OPTION mysql&gt; FLUSH PRIVILEGES **3.重启mysql /etc/init.d/mysql stop /etc/init.d/mysql start","categories":[],"tags":[],"keywords":[]},{"title":"git conclusion","slug":"git_conclusion","date":"2017-04-05T08:49:59.000Z","updated":"2017-04-05T08:54:20.337Z","comments":true,"path":"2017/04/05/git_conclusion/","link":"","permalink":"http://yoursite.com/2017/04/05/git_conclusion/","excerpt":"","text":"git是三个文件（本地–本地隐藏文件.git–远程仓库）先pull再add然后commit最后push 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com” cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com” (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag (打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中)","categories":[],"tags":[],"keywords":[]},{"title":"asynchronous","slug":"asynchronous","date":"2016-11-10T03:16:55.000Z","updated":"2017-04-05T08:32:05.357Z","comments":true,"path":"2016/11/10/asynchronous/","link":"","permalink":"http://yoursite.com/2016/11/10/asynchronous/","excerpt":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);","text":"利用回调函数实现异步非阻塞 var fs = require(“fs”);fs.readFile(‘input.txt’,’utf-8’,goajiawei(err,data) { if (err){ return console.error(err); } console.log(data.toString());});console.log(“高佳威end!”); 上面这段代码等价于： function gaojiawei(err,data){ if(err){ return console.error(err); } console.log(data.toString());}fs.readFile(‘input.txt’,’utf-8’,gaojiawei)console.log(“高佳威end!”);什么是回调函数？ 我们绕点远路来回答这个问题。 编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。 当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。 打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。 可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。 回调机制的优势 从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。 这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例： even.py回调函数1生成一个2k形式的偶数def double(x): return x * 2 回调函数2生成一个4k形式的偶数def quadruple(x): return x * 4 callback_demo.pyfrom even import * 中间函数接受一个生成偶数的函数作为参数返回一个奇数def getOddNumber(k, getEvenNumber): return 1 + getEvenNumber(k) 起始函数，这里是程序的主函数def main(): k = 1 #当需要生成一个2k+1形式的奇数时 i = getOddNumber(k, double) print(i) #当需要一个4k+1形式的奇数时 i = getOddNumber(k, quadruple) print(i) #当需要一个8k+1形式的奇数时 i = getOddNumber(k, lambda x: x * 8) print(i) if name == “main“: main() 运行callback_demp.py，输出如下：359 上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。 易被忽略的第三方 通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。 之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。 另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，我自己还没有完全搞明白，所以这里就不多说了。","categories":[],"tags":[],"keywords":[]},{"title":"To 365","slug":"To 365","date":"2016-11-06T14:57:12.000Z","updated":"2016-11-06T15:16:31.427Z","comments":true,"path":"2016/11/06/To 365/","link":"","permalink":"http://yoursite.com/2016/11/06/To 365/","excerpt":"","text":"都深夜了，这23岁的生日过的也不是那么的顺畅，我也能感受到这叹息的威力，划破黑衣的霾，直击人心得脉。想成事，必先受其苦，这是亘古不变的，经历了这么多事，风霜阴雨的，哪能忘却了？只是，日复一日的生活，水滴石穿着我们的爱心， 耐心和信心。唯有不忘初心，方能见前后，知因果。我写着写着自己都不知道要说啥，不妨罗列出来，锱铢一二： 干什么事都得定好目标，有了目标人才会有动力，即时面临艰难险阻，咬牙抬头的那一刻，看到梦想的目标，定然也会蓄力拼搏，殊死搏斗，不向命运低头； 出了较长远的大目标外（梦想如是。。。），也要定阶段性的小目标，一方面，小的目标可以较为容易的实现，可以激励自己，让自己获得长久“战斗”下去的勇气，另一方面，也告诫自己，困难还很多，千万别“轻敌”； 情感要有，纪律也不能丢掉。无规矩，不方圆，这种到底无需赘述。是非分明，奖惩分明，要的不是铁面无私，要的是活的明白！浑浑噩噩的，一天天过去了，一件件事经历了，然而并不能为以后树立良好的经验榜样，只有明明白白的活着，才能感受到生命的意义。除此以外，规矩的建立也是为了防止自己逾越雷池，犯下大错，因此，是亟待建立并付诸于心动的； 互相提高才是正道，共同进步才是正确。且说不到近朱者赤近墨者黑（没有那么严重），就用榜样来讲吧，良好的榜样，才能促进共同的进步，如果不思进取，最终的结果也定然不会太美丽。爱情终究会成为亲情，成为弥漫在你周围的空气一般，平淡，在平淡。长远的认识，或许会帮助自己更加轻松的理解生活的真谛。加油！","categories":[],"tags":[],"keywords":[]},{"title":"Nginx","slug":"Nginx","date":"2016-11-05T06:39:17.000Z","updated":"2016-11-05T06:57:41.397Z","comments":true,"path":"2016/11/05/Nginx/","link":"","permalink":"http://yoursite.com/2016/11/05/Nginx/","excerpt":"","text":"Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2016-11-05T06:07:27.123Z","updated":"2016-11-05T06:30:07.689Z","comments":true,"path":"2016/11/05/hello-world/","link":"","permalink":"http://yoursite.com/2016/11/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}